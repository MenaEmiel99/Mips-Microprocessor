//******************************************************************************
 * Engineer:      Hesham Khaled
 * Create date:   23:08:22 04/04/2020
 * Function Name: LCD_goToRowColumn
 * Description:   A function that's responsible for moving LCD's cursor
 *                to a specific position.
 * Inputs:        Decimal Values for Row and Column
 * Outputs:       void
 *
 *******************************************************************************//

 // ************************************************************************************************//
xLCD_goToRowColumn: NOP
 // Putting R0=0, Storing in R1 the Memory address of the Row to go //
    SUB  R0,R0,R0
    ADDI R0,R0,11
 // Putting R1=0, Storing in R1 the Memory address of the Column to go //
    SUB  R1,R1,R1
    ADDI R1,R1,12
 // Storing the value of the Row in R0, Value of Column in R1 //
 // Making R2=0 as initial value and the index, Making R3 the Bitmask Register //
    LW   R0,R0
    LW   R1,R1
    SUB  R2,R2,R2
    SUB  R3,R3,R3
 // Checking if it is Row (0), If yes, Jump, if no, add the index+1 //
    BEQ  R0,R2,10
    ADDI R2,R2,01
 // Checking if it is Row (1), If yes, Jump, if no, add the index+1 //
    BEQ  R0,R2,10
    ADD  R2,R2,R2
 // Checking if it is Row (2), If yes, Jump, if no, it must be Row (3) //
    BEQ  R0,R2,15
 // Position Address @ Row(3) = Column + 0x50 (80 Decimal) //
    ADDI R3,R3,20
    ADD  R3,R3,R3
    ADD  R3,R3,R3
    ADD  R3,R3,R3
    ADD  R1,R1,R3
    J    xEND
 // Position Address @ Row(0) = Column //
    ADDI R1,R1,00
    J    xEND
 // Position Address @ Row(1) = Column+0x40 (64 Decimal) //
    SUB  R3,R3,R3
    ADDI R3,R3,20
    ADD  R3,R3,R3
    ADD  R3,R3,R3
    ADDI R3,R3,04
    ADD  R1,R1,R3
    J    xEND
 // Position Address @ Row(2) = Column+0x10 //
    ADDI R1,R1,16
 // After the above code, R1 = The Address of the required position //

xEND: NOP
    // Command = Address OR 0b0000000010000000 //
    SUB  R3,R3,R3
    // Creating the bitmask 0b0000000010000000 for the Register //
    ADDI R3,R3,01
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    OR   R1,R1,R3
    // Clearing the index Register R2 //
    SUB  R2,R2,R2
 // RS=RW=0 --->  R2 AND 0b1110011111111111 //
    SUB  R3,R3,R3
 // Creating the bitmask 0b1110011111111111 for the Register //
    ADDI R3,R3,07
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    ADDI R3,R3,15
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    ADDI R3,R3,15
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    ADDI R3,R3,07
    AND R2,R2,R3‬
    OUT R2
    NOP
 // E=1    --->   R2 OR  0b0000010000000000 //
    SUB  R3,R3,R3
 // Creating the bitmask 0b0000010000000000 for the Register //
    ADDI R3,R3,01
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    OR   R2,R2,R3
    OUT R2
    NOP
 // Command<<2 = D0~D7 //
    SLL R1,R1
    SLL R1,R1
 // Sending command without changing any other bits in R1 ---> R1 OR 0b0000001111111100 //
    SUB R3,R3,R3
 // Creating the bitmask 0b0000001111111100 for the Register //
    ADDI R3,R3,15
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    ADDI R3,R3,15
    SLL  R3,R3
    SLL  R3,R3
    OR R1,R1,R3
    OUT R1
 // E=0   ---> R2 AND 0b1111101111111111 //
    SUB  R3,R3,R3
 // Creating the bitmask 0b1111101111111111 for the Register //
    ADDI R3,R3,15
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    ADDI R3,R3,01
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    ADDI R3,R3,15
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    SLL  R3,R3
    ADDI R3,R3,15
    SLL  R3,R3
    SLL  R3,R3
    ADDI R3,R3,03
    AND R2,R2,R3
    OUT R2
    NOP
    // Clearing The Registers used in the function (R0,R1,R2,R3) //
    ANDI R0,R0,00
    ANDI R1,R1,00
    ANDI R2,R2,00
    ANDI R3,R3,00
    JR R7


//******************************************************************************
 * Engineer:      Youssef Galal
 * Create date:   22:01:17 04/04/2020
 * Function Name: LCD_displayCharacter
 * Description:   takes the 8-bit value stored in a FIXED Memory Location
 *                to a specific position.
 * Inputs:        Data to be printed
 * Outputs:       void
 *
 *******************************************************************************//
//Function Discription: takes the 8-bit value in a FIXED address//
//and displays it on the LCD// 
//Name: Youssef Galal//
//Note: This file format is "*code* then a comment"//
xLCD_displayCharacter:
    SUB R1,R1,R1
    //putting R1=0//
    SUB R2,R2,R2 
    //putting R2=0//
    NOR R1,R1,R1
    // 0 NOR 0 = 1 so R1= 1111 1111 1111 1111//
    NOR R2,R2,R2
    // 0 NOR 0 = 1 so R2= 1111 1111 1111 1111//
    SRL R2,R2
    // R2 =  0111 1111 1111 1111//
    XOR R1,R1,R2
    // R1 = 1000 0000 0000 0000//
    SRL R1,R1
    // R1 = 0100 0000 0000 0000//
    SRL R1,R1
    // R1 = 0010 0000 0000 0000//
    SRL R1,R1
    // R1 = 0001 0000 0000 0000//
    SRL R1,R1
    // R1 = 0000 1000 0000 0000//
    SRL R1,R1
    // R1 = 0000 0100 0000 0000//
    IN R4
    //R4 = Getting the first 5 bits for masking//
    OR R1,R1,R4 
    // R1 = 5-bits concatenated with 100 0000 0000//
    OUT R1         
    // makes RS bit = 1 "Data mode"//
    // and RW bit =0 "Write data" // 
    SUB R0,R0,R0
    OR R0,R0,R7
    JAL xDelay
    // we must wait for the LCD to get it//
    SRL R2,R1     
    //R2 = 0000 0010 0000 0000//
    SRL R2,R1       
    //R2 = 0000 0001 0000 0000//
    OR R1,R1,R2    
    // R1 = 0000 0101 0000 0000//
    IN R4
    //R4 = Getting the first 5 bits for masking/
    OR R1,R1,R4 
    // R1 = 5-bits concatenated with 101 0000 0000//
    OUT R1          
    // makes E bit = 1//
    JAL xDelay
    SUB R3,R3,R3
    // cleaning R3 = 0//
    ORI R3,R3,10  
    // The data is stored in a fixed address = 10// 
    // R3 now has the address for my data//
    LW R3,R3
    // R3 now = my data //
    OR R3,R1,R3
    // bit manipulation//
    // R1 = 0000 0101 0000 0000//
    // R3 = 0000 0000 data data//
    // OR op. -> R3 = 0000 0101 data data//
    IN R4
    //R4 = Getting the first 5 bits for masking//
    OR R3,R3,R4 
    // R3 = 5-bits concatenated with 101 data data//
    OUT R3
    // showing the data on LCD //
    JAL xDelay
    SLL R2,R2
    // Check line 42 - R2 =  0000 0010 0000 0000//
    SLL R2,R2
    // R2 = 0000 0100 0000 0000//
    IN R4
    //R4 = Getting the first 5 bits for masking//
    OR R2,R2,R4 
    // R1 = 5-bits concatenated with 100 0000 0000//
    OUT R2        
    // R2 value clears E //
    JAL xDelay
    SUB R7,R7,R7
    OR R7,R7,R0
JR R7

// assumption of how the LCD is connected to the o/p port//
// if there is any change contact me//
//  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 //  
//  0  0  0  0  0  RS RW E  0  1  2  3  4  5  6  7  //


//Discription: this code creates 250000 and stores it in address 30//
//excute it in the main code//
//this block uses only R5 and R6 from regfile//
//Name: Youssef Galal//
SUB R6,R6,R6
SUB R5,R5,R5
//R6=0 R5=0//
ADDI R5,R5,30   
// Address 25//
ADDI R6,R6,24   
//     0000 0000 0001 1000//
SRL R6,R6       
//     0000 0000 0011 0000//
SRL R6,R6      
//     0000 0000 0110 0000//
SRL R6,R6       
//     0000 0000 1100 0000//
SRL R6,R6       
//     0000 0001 1000 0000//
SRL R6,R6       
//     0000 0011 0000 0000//
ADDI R6,R6,13   
//     0000 0011 0000 1101//
SRL R6,R6       
//     0000 0110 0001 1010//
SRL R6,R6       
//     0000 1100 0011 0100//
ADDI R6,R6,01   
//     0000 1100 0011 0101//
SRL R6,R6       
//     0001 1000 0110 1010//
SRL R6,R6       
//     0011 0000 1101 0100//
SRL R6,R6       
//     0110 0001 1010 1000//
SW R6,R5        
//     25000 IS STORED IN ADDRESS 30//
SUB R6,R6,R6
SUB R5,R5,R5
// R6=0 R5=0//
//END OF THE BLOCK//


//Function Discription: Delays for 1ms//
//assuming that the clock used is 25MHz,1 cycle takes 40ns//
//counter = 1ms/40ns = 25000 counts //
//25000 is stored by default in address 25d //
//Name: Youssef Galal//
xDelay:
    SUB R5,R5,R5
    SUB R6,R6,R6
    //R6=0,R5=0//
    ADDI R6,R6,30
    //having the address 25 in R6//
    LW R6,R6
    //loading data from address 25 in R6//
    xLoop:
        ADDI R5,R5,01
        //R5 accumulates untill it reaches 250000//
        NOP
        BEQ R5,R6,01
        //if R5 reaches R6 "25000" we will skip the jump line//
        J xLoop
        //if R5 doesn't reach R6 "25000" we will go to xLoop again//
    SUB R5,R5,R5
    SUB R6,R6,R6
    //getting out of the function and cleaning R5,R6//
    JR R7

// end of Galal's part//
//-------------------------------------------------------------------------------------------//
//******************************************************************************
 * Engineer:      Youssef Taha
 * Create date:   20:24:22 05/04/2020
 * Function Name: Set_Initial_Value
 * Description:   A function that's responsible for setting initial value
                  for the counter of the pressed key
  *******************************************************************************//
  xSet_initial_value:Nop
  SUB	R1,R1,R1
  SUB	R2,R2,R2
  SUB	R3,R3,R3
  SUB	R4,R4,R4
  //CLEARING R1,R2,R3,R4=0//
  ADDI	R4,R4,021
  //STORING THE VALUE OF MEMORRY ADDRESS IN R4//
  ADDI	R2,R2,020
  //STORING THE VALUE OF MEMORRY ADDRESS IN R2//
  LW	R1,R2
  //LOAD THE VALUE OF M[20] IN R1??
  ANDI	R1,R1,015
  //PUTTING R1="0000 0000 0000 1111"//
  SUB	R2,R2,R2
  //CLEARING R2=0//
  ADDI	R2,R2,02
  //PUTTING R2=2//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 2 THEN JUMP 22 LINES
  TO CONDITION OF 2//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,03
  //PUTTING R2=3//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 3 THEN JUMP 22 LINES
  TO CONDITION OF 3//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,04
  //PUTTING R2=4//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 3 THEN JUMP 22 LINES
  TO CONDITION OF 4//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,05
  //PUTTING R2=5//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 5 THEN JUMP 22 LINES
  TO CONDITION OF 5//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,06
  //PUTTING R2=6//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 6 THEN JUMP 22 LINES
  TO CONDITION OF 6//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,07
  //PUTTING R2=7//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 7 THEN JUMP 22 LINES
  TO CONDITION OF 7//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,08
  //PUTTING R2=8//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 8 THEN JUMP 22 LINES
  TO CONDITION OF 8//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,09
  //PUTTING R2=9//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 9 THEN JUMP 22 LINES
  TO CONDITION OF 9//
  //*****LEST OF NUMBERS CONDITIONS*****//
  ADDI	R3,R3,01
  //PUTTING R3=1 AS THIS IS THE INITIAL VALUE FOR THE 2 BUTTON//
  SW		R3,R4
  //STORING THE VALUE OF R4 IN THE MEMORY ADDRESS LOCATED IN R3//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_pressed_keys FUNCTION//
  ADDI	R3,R3,04
  //PUTTING R3=4 AS THIS IS THE INITIAL VALUE OF '3' BUTTON//
  SW	R3,R4	
  //STORING THE VALUW OF R4 IN THE MEMORY ADDRESS LOCATED IN R3//
  J		xcounter_of_pressed_kesys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
  ADDI	R3,R3,07
  //PUTTING R3=7 AS THIS IS THE INITIAL VALUW OF '4' BUTTON//
  SW	R3,R3	
  //STORING THE VALUE OF R4 IN THE MEMORY ADDRESS LOCATED IN R3//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
  ADDI	R3,R3,010
  //PUTTING R3=10 AS THIS IS THE INITIAL VALUE OF '5' BUTTON//
  SW	R3,R4
  //STORE THE VALUE OF R4 IN THE MEMORY ADDRESS LOCATED IN R3//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
  ADDI	R3,R3,013
  //PUTTING R3=13 AS THIS IS THE INITIAL VALUE OF '6' BUTTON//
  SW	R3,R4
  //STORING THE VALUE OF R3 IN MEMORY ADDRESS LOCATED IN R4//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
  ADDI R3,R3,016
  //PUTTING R3=16 AS THIS IS THE INITIAL VALUE OF '7' BUTTON//
  SW	R3,R4 
  //STORING THE VALUE OF R4 IN MEMORY ADDRESS LOCATED IN R3//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
  ADDI	R3,R3,020
  //PUTTING R3=20 AS THIS IS THE INITIAL VALUE OF '8' BUTTON//
  SW	R3,R4
  //STORING THE VALUE OF R4 IN MEMORY ADDRESS LOCATED IN R3//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
  ADDI	R3,R3,023
  //PUTTING R3=23 AS THIS IS THE INITIAL VALUE OF '9' BUTTON//
  SW	R3,R4
  //STORING THE VALUE OF R3 IN MEMORY ADDRESS LOCATED IN R4//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
//-------------------------------------------------------------------------------------------------------//
//******************************************************************************
 * Engineer:      Yahya Hamdy
 * Create date:   1:16:17 06/04/2020
 * Function Name: xCounter_Of_Pressed_Keys
 * Description:  Converting the input to a value poinnting at the 
                 number of the wanted alphapetic letter as the used assembler 
		 is not supporting an immediate value more than 031
 * Inputs:        Data to be printed and initial value of the counter
 * Outputs:       New value of the counter that points at the number 
                  of the wanted alphapetic letter
 *******************************************************************************//
xCounter_Of_Pressed_Keys:NOP
//Clear Registers R1,R2,R3,R4//
SUB R1,R1,R1
SUB R2,R2,R2
SUB R3,R3,R3
SUB R4,R4,R4

//Setting R3,R4 with the values of the input and counter initial value memory locations//
ADDI R3,R3,020
ADDI R4,R4,021

//Storing the entered value in R1 and the initial value of the counter in R2//
LW R1,R3
LW R2,R4 

//Shift Right R1 by 4 bits and storing the shifted value in R3//
SUB R3,R3,R3
SRL R3,R1
SRL R3,R3
SRL R3,R3
SRL R3,R3

//Jump to the display procedure after reading the input successfully and keeping the value of the counter unchanged//
ANDI R3,R3,015
SUB R4,R4,R4
BEQ R3,R4,#OFFSET

//The key is pressed again so the value of the counter will be incremented//
ADDI R2,R2,01

//Store the new value of the counter in memory//
SUB R3,R3,R3
ADDI R4,R4,021
SW R2,R4

//Read the next nibble and check if the key is pressed again//
SRL R3,R1
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
ANDI R3,R3,015
SUB R4,R4,R4
BEQ R3,R4,#OFFSET
ADDI R2,R2,01
SUB R3,R3,R3
ADDI R4,R4,021
SW R2,R4

//Read the next nibble and check if the key is pressed again//
SRL R3,R1
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
ANDI R3,R3,015
SUB R4,R4,R4
BEQ R3,R4,#OFFSET
ADDI R2,R2,01
SUB R3,R3,R3
ADDI R4,R4,021
SW R2,R4

//The input is read successfully , Jump to the display procedure//
J xSend_"YOU ENTERD"_Message
//-------------------------------------------------------------------------------------------------------------------------------------//
//***********************************************
*Engineer        : Mohamed Ammar
*Creat date      : 6/4/2020 
*Edited          : 7/4/2020
*Function name   : Send_"YOU ENTERD"_Message
*Description     : A function to print string 

***********************************************//

 xSend_"YOU ENTERD"_Message

 // PRINTING Y //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,29
 ADDI R2,R2,10
 SW   R1,R2

 // GOTO ROW 1 // 
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADDI R1,R1,1
 ADDI R2,R2,11
 SW   R1,R2
 
 //GOTO COL1 //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADDI R1,R1,1
 ADDI R2,R2,12
 SW   R1,R2
 
 JAL xLCD_goToRowColumn
 JAL xLCD_displayCharacter 
 
 // PRINTING O //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,19
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 

 // PRINTING U //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,25
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 
 
 // PRINTING SPACE //
 SUB  R1,R1,R1  
 SUB  R2,R2,R2
 ADDI R1,R1,30
 ADDI R1,R1,2
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 
 
 // PRINTING E //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,9
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter

 // PRINTING N //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,18
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter

 // PRINTING T //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,24
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter

 // PRINTING E //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,9
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 

 // PRINTING R //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,22
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter

 // PRINTING E //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,9
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 

 // PRINTING D //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,8
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter

 // PRINTING : //
 SUB  R1,R1,R1  
 SUB  R2,R2,R2
 ADDI R1,R1,30
 ADDI R1,R1,28
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 
 
 // PRINTING SPACE //
 SUB  R1,R1,R1  
 SUB  R2,R2,R2
 ADDI R1,R1,30
 ADDI R1,R1,2
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 
 

 // ASCII CODE OF REQUIRED LETTER //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADDI R2,R2,21
 LW   R1,R2
 ADDI R1,R1,30 
 ADDI R1,R1,30
 ADDI R1,R1,4

 //  PRINTING THE LETTER  //
 SUB  R2,R2,R2
 ADDI R2,R2,10
 SW   R1,R2 
 JAL xLCD_displayCharacter 
//-------------------------------------------------------------------------------------------------------------------------------------// 