<<<<<<< HEAD
-------------------------------------------------------------------------------------------
//START OF GALAL'S PART//
//Function Description: takes the 8-bit value in a FIXED address//
//and displays it on the LCD// 
//Name: Youssef Galal//
//Note: This file format is "*code* then a comment"//
xLCD_displayCharacter:
=======
//******************************************************************************
 * Engineer:      Hesham Khaled
 * Create date:   23:08:22 04/04/2020
 * Function Name: LCD_goToRowColumn
 * Description:   A function that's responsible for moving LCD's cursor
 *                to a specific position.
 * Inputs:        Decimal Values for Row and Column
 * Outputs:       void
 *
 *******************************************************************************//

xLCD_goToRowColumn:
 // Putting R0=0, Storing in R1 the Memory address of the Row to go //
    SUB  R0,R0,R0
    ADDI R0,R0,11
 // Putting R1=0, Storing in R1 the Memory address of the Column to go //
    SUB  R1,R1,R1
    ADDI R1,R1,12
 // Storing the value of the Row in R0, Value of Column in R1 //
 // Making R2=0 as initial value and the index, Making R3 the Bitmask Register //
    LW   R0,R0
    LW   R1,R1
    SUB  R2,R2,R2
    SUB  R3,R3,R3
 // Checking if it is Row (0), If yes, Jump, if no, add the index+1 //
    BEQ  R0,R2,10
    ADDI R2,R2,01
 // Checking if it is Row (1), If yes, Jump, if no, add the index+1 //
    BEQ  R0,R2,10
    ADD  R2,R2,R2
 // Checking if it is Row (2), If yes, Jump, if no, it must be Row (3) //
    BEQ  R0,R2,15
 // Position Address @ Row(3) = Column + 0x50 (80 Decimal) //
    ADDI R3,R3,20
    ADD  R3,R3,R3
    ADD  R3,R3,R3
    ADD  R3,R3,R3
    ADD  R1,R1,R3
    J    END
 // Position Address @ Row(0) = Column //
    ADDI R1,R1,00
    J    END
 // Position Address @ Row(1) = Column+0x40 (64 Decimal) //
    SUB  R3,R3,R3
    ADDI R3,R3,20
    ADD  R3,R3,R3
    ADD  R3,R3,R3
    ADDI R3,R3,04
    ADD  R1,R1,R3
    J    END
 // Position Address @ Row(2) = Column+0x10 //
    ADDI R1,R1,16
 // After the above code, R1 = The Address of the required position //

xEND:
    // Command = Address OR 0b0000000010000000 //
    SUB  R3,R3,R3
    // Creating the bitmask 0b0000000010000000 for the Register //
    ADDI R3,R3,01
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    OR   R1,R1,R3
    // Clearing the index Register R2 //
    SUB  R2,R2,R2
 // RS=RW=0 --->  R2 AND 0b1110011111111111 //
    SUB  R3,R3,R3
 // Creating the bitmask 0b1110011111111111 for the Register //
    ADDI R3,R3,07
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    ADDI R3,R3,15
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    ADDI R3,R3,15
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    ADDI R3,R3,07
    AND R2,R2,R3‬
    OUT R2
    NOP
 // E=1    --->   R2 OR  0b0000010000000000 //
    SUB  R3,R3,R3
 // Creating the bitmask 0b0000010000000000 for the Register //
    ADDI R3,R3,01
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    OR   R2,R2,R3
    OUT R2
    NOP
 // Command<<2 = D0~D7 //
    SHL R1,R1
    SHL R1,R1
 // Sending command without changing any other bits in R1 ---> R1 OR 0b0000001111111100 //
    SUB R3,R3,R3
 // Creating the bitmask 0b0000001111111100 for the Register //
    ADDI R3,R3,15
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    ADDI R3,R3,15
    SHL  R3,R3
    SHL  R3,R3
    OR R1,R1,R3
    OUT R1
 // E=0   ---> R2 AND 0b1111101111111111 //
    SUB  R3,R3,R3
 // Creating the bitmask 0b1111101111111111 for the Register //
    ADDI R3,R3,15
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    ADDI R3,R3,01
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    ADDI R3,R3,15
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    SHL  R3,R3
    ADDI R3,R3,15
    SHL  R3,R3
    SHL  R3,R3
    ADDI R3,R3,03
    AND R2,R2,R3
    OUT R2
    NOP
    // Clearing The Registers used in the function (R0,R1,R2,R3) //
    ANDI R0,R0,00
    ANDI R1,R1,00
    ANDI R2,R2,00
    ANDI R3,R3,00
    JR R7


//******************************************************************************
 * Engineer:      Youssef Galal
 * Create date:   22:01:17 04/04/2020
 * Function Name: LCD_displayCharacter
 * Description:   takes the 8-bit value stored in a FIXED Memory Location
 *                to a specific position.
 * Inputs:        Data to be printed
 * Outputs:       void
 *
 *******************************************************************************//
//Function Discription: takes the 8-bit value in a FIXED address//
//and displays it on the LCD// 
//Name: Youssef Galal//
//Note: This file format is "*code* then a comment"//
xLCD_displayCharacter:
    SUB R1,R1,R1
    //putting R1=0//
    SUB R2,R2,R2 
    //putting R2=0//
    NOR R1,R1,R1
    // 0 NOR 0 = 1 so R1= 1111 1111 1111 1111//
    NOR R2,R2,R2
    // 0 NOR 0 = 1 so R2= 1111 1111 1111 1111//
    SRL R2,R2
    // R2 =  0111 1111 1111 1111//
    XOR R1,R1,R2
    // R1 = 1000 0000 0000 0000//
    SRL R1,R1
    // R1 = 0100 0000 0000 0000//
    SRL R1,R1
    // R1 = 0010 0000 0000 0000//
    SRL R1,R1
    // R1 = 0001 0000 0000 0000//
    SRL R1,R1
    // R1 = 0000 1000 0000 0000//
    SRL R1,R1
    // R1 = 0000 0100 0000 0000//
    IN R4
    //R4 = Getting the first 5 bits for masking//
    OR R1,R1,R4 
    // R1 = 5-bits concatenated with 100 0000 0000//
    OUT R1         
    // makes RS bit = 1 "Data mode"//
    // and RW bit =0 "Write data" // 
    SUB R0,R0,R0
    ORI R0,R0,R7
    JAL xDelay
    // we must wait for the LCD to get it//
    SRL R2,R1     
    //R2 = 0000 0010 0000 0000//
    SRL R2,R1       
    //R2 = 0000 0001 0000 0000//
    OR R1,R1,R2    
    // R1 = 0000 0101 0000 0000//
    IN R4
    //R4 = Getting the first 5 bits for masking/
    OR R1,R1,R4 
    // R1 = 5-bits concatenated with 101 0000 0000//
    OUT R1          
    // makes E bit = 1//
    JAL xDelay
    SUB R3,R3,R3
    // cleaning R3 = 0//
    ORI R3,R3,10  
    // The data is stored in a fixed address = 10// 
    // R3 now has the address for my data//
    LW R3,R3
    // R3 now = my data //
    OR R3,R1,R3
    // bit manipulation//
    // R1 = 0000 0101 0000 0000//
    // R3 = 0000 0000 data data//
    // OR op. -> R3 = 0000 0101 data data//
    IN R4
    //R4 = Getting the first 5 bits for masking//
    OR R3,R3,R4 
    // R3 = 5-bits concatenated with 101 data data//
    OUT R3
    // showing the data on LCD //
    JAL xDelay
    SLL R2,R2
    // Check line 42 - R2 =  0000 0010 0000 0000//
    SLL R2,R2
    // R2 = 0000 0100 0000 0000//
    IN R4
    //R4 = Getting the first 5 bits for masking//
    OR R2,R2,R4 
    // R1 = 5-bits concatenated with 100 0000 0000//
    OUT R2        
    // R2 value clears E //
    JAL xDelay
    SUB R7,R7,R7
    ORI R7,R7,R0
JR R7

// assumption of how the LCD is connected to the o/p port//
// if there is any change contact me//
//  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 //  
//  0  0  0  0  0  RS RW E  0  1  2  3  4  5  6  7  //


//Discription: this code creates 250000 and stores it in address 25//
//excute it in the main code//
//this block uses only R5 and R6 from regfile//
//Name: Youssef Galal//
SUB R6,R6,R6
SUB R5,R5,R5
//R6=0 R5=0//
ADDI R5,R5,25   
// Address 25//
ADDI R6,R6,24   
//     0000 0000 0001 1000//
SRL R6,R6       
//     0000 0000 0011 0000//
SRL R6,R6      
//     0000 0000 0110 0000//
SRL R6,R6       
//     0000 0000 1100 0000//
SRL R6,R6       
//     0000 0001 1000 0000//
SRL R6,R6       
//     0000 0011 0000 0000//
ADDI R6,R6,13   
//     0000 0011 0000 1101//
SRL R6,R6       
//     0000 0110 0001 1010//
SRL R6,R6       
//     0000 1100 0011 0100//
ADDI R6,R6,01   
//     0000 1100 0011 0101//
SRL R6,R6       
//     0001 1000 0110 1010//
SRL R6,R6       
//     0011 0000 1101 0100//
SRL R6,R6       
//     0110 0001 1010 1000//
SW R6,R5        
//     25000 IS STORED IN ADDRESS 25//
SUB R6,R6,R6
SUB R5,R5,R5
// R6=0 R5=0//
//END OF THE BLOCK//


//Function Discription: Delays for 1ms//
//assuming that the clock used is 25MHz,1 cycle takes 40ns//
//counter = 1ms/40ns = 25000 counts //
//25000 is stored by default in address 25d //
//Name: Youssef Galal//
xDelay:
    SUB R5,R5,R5
    SUB R6,R6,R6
    //R6=0,R5=0//
    ADDI R6,R6,25
    //having the address 25 in R6//
    LW R6,R6
    //loading data from address 25 in R6//
    xLoop:
        ADDI R5,R5,01
        //R5 accumulates untill it reaches 250000//
        NOP
        BEQ R5,R6,01
        //if R5 reaches R6 "25000" we will skip the jump line//
        J xLoop
        //if R5 doesn't reach R6 "25000" we will go to xLoop again//
    SUB R5,R5,R5
    SUB R6,R6,R6
    //getting out of the function and cleaning R5,R6//
    JR R7

// end of Galal's part//
-------------------------------------------------------------------------------------------