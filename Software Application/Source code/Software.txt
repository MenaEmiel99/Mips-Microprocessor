//******************************************************************************
 * Engineer:      Hesham Khaled
 * Create date:   23:08:22 04/04/2020
 * Function Name: LCD_goToRowColumn
 * Description:   A function that's responsible for moving LCD's cursor
 *                to a specific position.
 * Inputs:        Decimal Values for Row and Column
 * Outputs:       void
 *
 // *****************************************************************************//
xLCD_goToRowColumn: NOP
 // Putting R0=0, Storing in R0 the Memory address of the Row to go
    SUB  R0,R0,R0
    ADDI R0,R0,11
 // Putting R1=0, Storing in R1 the Memory address of the Column to go
    SUB  R1,R1,R1
    ADDI R1,R1,12
 // Storing the value of the Row in R0, Value of Column in R1
 // Making R2=0 as initial value and the index
    LW   R0,R0
    LW   R1,R1
    SUB  R2,R2,R2
 // Checking if it is Row (0), If yes, Jump, if no, add the index+1
    BEQ  R0,R2,09
    ADDI R2,R2,01
 // Checking if it is Row (1), If yes, Jump, if no, add the index+1
    BEQ  R0,R2,08
    ADD  R2,R2,R2
 // Checking if it is Row (2), If yes, Jump, if no, it must be Row (3)
    BEQ  R0,R2,11
 // Position Address @ Row(3) = Column + 0x50 (80 Decimal)
    ADDI R1,R1,20
    ADD  R1,R1,20
    ADD  R1,R1,20
    ADD  R1,R1,20
    J    xEND
 // Position Address @ Row(0) = Column //
    J    xEND
 // Position Address @ Row(1) = Column+0x40 (64 Decimal)
    ADDI R1,R1,20
    ADDI R1,R1,20
    ADDI R1,R1,20
    ADDI R1,R1,04
    J    xEND
 // Position Address @ Row(2) = Column+0x10 (16 Decimal)
    ADDI R1,R1,16

 // R1= Address of the required position to go to.
   1. In this label, I am setting the command to be sent
    as, Command = Address OR 0b0000000010000000
   2. and calling the command function

xEND: NOP
 // 1.First step (Command = Address OR 0b0000000010000000)
    SUB  R0,R0,R0
    ADDI R0,R0,01
    SLL  R0,R0
    SLL  R0,R0
    SLL  R0,R0
    SLL  R0,R0
    SLL  R0,R0
    SLL  R0,R0
    SLL  R0,R0
    OR   R1,R1,R0
 // 2.   Second step (Calling Command Function)
 // 2.A: Storing Command in M[10]
 // 2.B: Storing Main Procedure return address (R7) in M[19] 
 // 2.C: Re-Storing Main Procedure return M[19] in (R7)
    SUB  R0,R0,R0
    ADDI R0,R0,10
    SW   R1,R0
    ADDI R0,R0,09
    SW   R7,R0
    JAL  xLCD_sendCommand
    SUB  R0,R0,R0
    ADDI R0,R0,19
    LW   R7,R0
 // Clearing used Registers (R0,R1,R2)
    SUB  R0,R0,R0
    SUB  R1,R1,R1
    SUB  R2,R2,R2
    JR R7
    
//******************************************************************************
 * Engineer:      Youssef Galal
 * Create date:   22:01:17 04/04/2020
 * Function Name: LCD_displayCharacter
 * Description:   takes the 8-bit value stored in a FIXED Memory Location
 *                to a specific position.
 * Inputs:        Data to be printed
 * Outputs:       void
 *
 *******************************************************************************//
//Function Discription: takes the 8-bit value in a FIXED address//
//and displays it on the LCD// 
//Name: Youssef Galal//
//Note: This file format is "*code* then a comment"//
xLCD_displayCharacter:
    SUB R1,R1,R1
    //putting R1=0//
    SUB R2,R2,R2 
    //putting R2=0//
    NOR R1,R1,R1
    // 0 NOR 0 = 1 so R1= 1111 1111 1111 1111//
    NOR R2,R2,R2
    // 0 NOR 0 = 1 so R2= 1111 1111 1111 1111//
    SRL R2,R2
    // R2 =  0111 1111 1111 1111//
    XOR R1,R1,R2
    // R1 = 1000 0000 0000 0000//
    SRL R1,R1
    // R1 = 0100 0000 0000 0000//
    SRL R1,R1
    // R1 = 0010 0000 0000 0000//
    SRL R1,R1
    // R1 = 0001 0000 0000 0000//
    SRL R1,R1
    // R1 = 0000 1000 0000 0000//
    SRL R1,R1
    // R1 = 0000 0100 0000 0000//
    IN R4
    //R4 = Getting the first 5 bits for masking//
    OR R1,R1,R4 
    // R1 = 5-bits concatenated with 100 0000 0000//
    OUT R1         
    // makes RS bit = 1 "Data mode"//
    // and RW bit =0 "Write data" // 
    SUB R0,R0,R0
    OR R0,R0,R7
    JAL xDelay
    // we must wait for the LCD to get it//
    SRL R2,R1     
    //R2 = 0000 0010 0000 0000//
    SRL R2,R1       
    //R2 = 0000 0001 0000 0000//
    OR R1,R1,R2    
    // R1 = 0000 0101 0000 0000//
    IN R4
    //R4 = Getting the first 5 bits for masking/
    OR R1,R1,R4 
    // R1 = 5-bits concatenated with 101 0000 0000//
    OUT R1          
    // makes E bit = 1//
    JAL xDelay
    SUB R3,R3,R3
    // cleaning R3 = 0//
    ORI R3,R3,10  
    // The data is stored in a fixed address = 10// 
    // R3 now has the address for my data//
    LW R3,R3
    // R3 now = my data //
    OR R3,R1,R3
    // bit manipulation//
    // R1 = 0000 0101 0000 0000//
    // R3 = 0000 0000 data data//
    // OR op. -> R3 = 0000 0101 data data//
    IN R4
    //R4 = Getting the first 5 bits for masking//
    OR R3,R3,R4 
    // R3 = 5-bits concatenated with 101 data data//
    OUT R3
    // showing the data on LCD //
    JAL xDelay
    SLL R2,R2
    // Check line 42 - R2 =  0000 0010 0000 0000//
    SLL R2,R2
    // R2 = 0000 0100 0000 0000//
    IN R4
    //R4 = Getting the first 5 bits for masking//
    OR R2,R2,R4 
    // R1 = 5-bits concatenated with 100 0000 0000//
    OUT R2        
    // R2 value clears E //
    JAL xDelay
    SUB R7,R7,R7
    OR R7,R7,R0
JR R7

// assumption of how the LCD is connected to the o/p port//
// if there is any change contact me//
//  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 //  
//  0  0  0  0  0  RS RW E  0  1  2  3  4  5  6  7  //


//Discription: this code creates 250000 and stores it in address 30//
//excute it in the main code//
//this block uses only R5 and R6 from regfile//
//Name: Youssef Galal//
SUB R6,R6,R6
SUB R5,R5,R5
//R6=0 R5=0//
ADDI R5,R5,30   
// Address 25//
ADDI R6,R6,24   
//     0000 0000 0001 1000//
SRL R6,R6       
//     0000 0000 0011 0000//
SRL R6,R6      
//     0000 0000 0110 0000//
SRL R6,R6       
//     0000 0000 1100 0000//
SRL R6,R6       
//     0000 0001 1000 0000//
SRL R6,R6       
//     0000 0011 0000 0000//
ADDI R6,R6,13   
//     0000 0011 0000 1101//
SRL R6,R6       
//     0000 0110 0001 1010//
SRL R6,R6       
//     0000 1100 0011 0100//
ADDI R6,R6,01   
//     0000 1100 0011 0101//
SRL R6,R6       
//     0001 1000 0110 1010//
SRL R6,R6       
//     0011 0000 1101 0100//
SRL R6,R6       
//     0110 0001 1010 1000//
SW R6,R5        
//     25000 IS STORED IN ADDRESS 30//
SUB R6,R6,R6
SUB R5,R5,R5
// R6=0 R5=0//
//END OF THE BLOCK//


//Function Discription: Delays for 1ms//
//assuming that the clock used is 25MHz,1 cycle takes 40ns//
//counter = 1ms/40ns = 25000 counts //
//25000 is stored by default in address 25d //
//Name: Youssef Galal//
xDelay:
    SUB R5,R5,R5
    SUB R6,R6,R6
    //R6=0,R5=0//
    ADDI R6,R6,30
    //having the address 25 in R6//
    LW R6,R6
    //loading data from address 25 in R6//
    xLoop:
        ADDI R5,R5,01
        //R5 accumulates untill it reaches 250000//
        NOP
        BEQ R5,R6,01
        //if R5 reaches R6 "25000" we will skip the jump line//
        J xLoop
        //if R5 doesn't reach R6 "25000" we will go to xLoop again//
    SUB R5,R5,R5
    SUB R6,R6,R6
    //getting out of the function and cleaning R5,R6//
    JR R7

// end of Galal's part//

//******************************************************************************/
 * Engineer:      Asmaa Sameh
 * Create date:     07/04/2020
 *Function Name: LCD_sendCommand
 *Description: Sends a certain command to the LCD through the LCD’s control pins
 *Inputs: Decimal value for command number
 *Return: void
 *
 *****************************************************************************//
//  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 //  
//  0  0  0  RS RW E  0  1  2  3  4  5  6  7  0 0 //

xLCD_sendCommand: NOP
SUB R1,R1,R1
// RS=0   RW=0//
ORI R1,R1,03h
// R1 = 0000 0000 0000 0011//
SUB R2,R2,R2
ORI R2,R2,07h
//R2 = 0000 0000 0000 0111//
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
//R2 = 1110 0000 0000 0000//
OR R1,R2,R1
//R1= 1110 0000 0000 0011//

SUB R2,R2,R2

IN R6 
AND R2,R1,R6

// R2 have 5-Bit masking //
// RS=0   RW=0//

 SUB R0,R0,R0
ORI R0,R0,18h
SW R0,R7

JAL xDelay 

SUB R3,R3,R3
ORI R3,R3,10
// data is stored in fixed address=10//
// address is stored in R3//
LW R3,R3
//R3 is the command now//
// R3 = 0000 0000 CMD CMD//
SLL R3, R3
SLL R3,R3
// R3= 0000 00 CMD CMD 00// 

OR R2,R3,R2
//R2= 5-bit masking + CMD value //

SUB R0,R0,R0
ORI R0,R0,15h
SW R0,R1
// Store value of R1 in memory location 15//

SUB R0,R0,R0
ORI R0,R0,16h
SW R0,R2
// Store value of R2 in memory location 16//

SUB R0,R0,R0
ORI R0,R0,17h
SW R0,R3
// Store value of R3 in memory location 17//


J xCmp1
J xCmp2
JAL xLCD_goToRowColumN

SUB R0,R0,R0
ORI R0,R0,15h
LW R1,R0

SUB R0,R0,R0
ORI R0,R0,16h
LW R2,R0

SUB R0,R0,R0
ORI R0,R0,17h
LW R3,R0
// put values in their regs again from memo// 

JAL xDelay

SUB R4,R4,R4
SUB R5,R5,R5
NOR R4,R4,R4
//R4= FFFF //
NOR R5,R5,R5
//R5= FFFF//
SRL R4,R4
// R4= 7FFF //
XOR R4,R5,R4
//R4= 1000 0000 0000 0000//
SRL R4,R4
SRL R4,R4
SRL R4,R4
SRL R4,R4
SRL R4,R4
// R4 = 0000 0100 0000 0000 //
OR R2,R4,R2
// E=1 //

OUT R2 
 
JAL xDelay 

IN R6 
AND R1,R6,R1
// R1=1110 0000 0000 0011//
// 5- bit masking connected //
AND R2,R1,R2

OUT R2
// E=0//


JAL xDelay



SUB R7,R7,R7
OR R7,R7,18h
LW R7,R7

JR R7

xCmp1: NOP
SUB R0,R0,R0
ADDI R0,R0,01
BEQ R3,R0,R3
JAL xClear_LCD 
JR7
// compare value of CMD by 01 ( clear fun)//

xCmp2: NOP 
SUB R0,R0,R0
ADDI R0,R0,02
BEQ R3,R0,R3
JAL xIni_LCD
JR7
// compare value of CMD by 02 (inti fun)//
//-------------------------------------------------------------------------------------------//


//***********************************************
*Engineer        : Mena Emiel
*Create date     : 7/4/2020 
*Function name   : Store_PressedKey
*Description     : Store value of the pressed key from the keypad
***********************************************//
xStore_PressedKey:
JAL  xKeypad_GetPressedKey
//Clear the registers//
SUB  R1,R1,R1
SUB  R2,R2,R2
SUB  R3,R3,R3
SUB  R4,R4,R4
//Load the Value of the pressed key from the memory location M[00]//
ADDI R4,R4,000
LW   R1,R4
//R4=0, Sending the stored value from R1 to the memory location M[20]//
SUB  R4,R4,R4
ADDI R4,R4,020
SW   R1,R4
//Getting the pressed key which is '*' or '#'//
xCheckInput:
JAL  xKeypad_GetPressedKey
//Clear the registers//
SUB  R1,R1,R1
SUB  R2,R2,R2
SUB  R3,R3,R3
SUB  R4,R4,R4
//Store the value of '*' in R3//
ADDI R3,R3,00
//Load the previous value of the pressed key from M[20] to R1//
ADDI R4,R4,020
LW   R1,R4
//R4=0, Check if the user pressed '*'//
SUB  R4,R4,R4
ADDI R4,R4,000
LW   R2,R4
BEQ  R2,R3,02
J    xHashtag_Pressed
//if the user pressed '*', shifting the register value to store next pressed key//
SRL  R1,R1
SRL  R1,R1
SRL  R1,R1
SRL  R1,R1
//R4=0, Sending the stored value from R1 to the memory location M[20]//
SUB  R4,R4,R4
ADDI R4,R4,020
SW   R1,R4
//Getting the pressed key after the '*'//
JAL  xKeypad_GetPressedKey
//Clear the registers//
SUB  R1,R1,R1
SUB  R2,R2,R2
SUB  R3,R3,R3
SUB  R4,R4,R4
//Load the previous value of the pressed key from M[20] to R1//
ADDI R4,R4,020
LW   R1,R4
//R4=0, Load the next pressed key in R2//
SUB  R4,R4,R4
ADDI R4,R4,000
LW   R2,R4
OR   R1,R1,R2
//R4=0, Sending the stored value from R1 to the memory location M[20]//
SUB  R4,R4,R4
ADDI R4,R4,020
SW   R1,R4
//Jump to the check of the '*' and '#'//
J    xCheckInput
//R4=0, if the user pressed '#', sending the stored value to the memory location M[20]//
xHashtag_Pressed:
SUB  R4,R4,R4
ADDI R4,R4,020
SW   R1,R4
J    xSet_initial_value
//-------------------------------------------------------------------------------------------------//
//******************************************************************************
 *Engineer:        Youssef Taha
 * Create date:   20:24:22 05/04/2020
 * Function Name: Set_Initial_Value
 * Description:   A function that's responsible for setting initial value
                  for the counter of the pressed key
  *******************************************************************************//
  xSet_initial_value:Nop
  SUB	R1,R1,R1
  SUB	R2,R2,R2
  SUB	R3,R3,R3
  SUB	R4,R4,R4
  //CLEARING R1,R2,R3,R4=0//
  ADDI	R4,R4,021
  //STORING THE VALUE OF MEMORY ADDRESS IN R4//
  ADDI	R2,R2,020
  //STORING THE VALUE OF MEMORY ADDRESS IN R2//
  LW	R1,R2
  //LOAD THE VALUE OF M[20] IN R1??
  ANDI	R1,R1,015
  //PUTTING R1="0000 0000 0000 ****"//
  SUB	R2,R2,R2
  //CLEARING R2=0//
  ADDI	R2,R2,02
  //PUTTING R2=2//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 2 THEN JUMP 22 LINES
  TO CONDITION OF 2//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,03
  //PUTTING R2=3//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 3 THEN JUMP 22 LINES
  TO CONDITION OF 3//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,04
  //PUTTING R2=4//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 3 THEN JUMP 22 LINES
  TO CONDITION OF 4//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,05
  //PUTTING R2=5//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 5 THEN JUMP 22 LINES
  TO CONDITION OF 5//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,06
  //PUTTING R2=6//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 6 THEN JUMP 22 LINES
  TO CONDITION OF 6//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,07
  //PUTTING R2=7//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 7 THEN JUMP 22 LINES
  TO CONDITION OF 7//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,08
  //PUTTING R2=8//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 8 THEN JUMP 22 LINES
  TO CONDITION OF 8//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,09
  //PUTTING R2=9//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 9 THEN JUMP 22 LINES
  TO CONDITION OF 9//
  //*****LEST OF NUMBERS CONDITIONS*****//
  ADDI	R3,R3,01
  //PUTTING R3=1 AS THIS IS THE INITIAL VALUE FOR THE 2 BUTTON//
  SW		R3,R4
  //STORING THE VALUE OF R4 IN THE MEMORY ADDRESS LOCATED IN R3//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_pressed_keys FUNCTION//
  ADDI	R3,R3,04
  //PUTTING R3=4 AS THIS IS THE INITIAL VALUE OF '3' BUTTON//
  SW	R3,R4	
  //STORING THE VALUW OF R4 IN THE MEMORY ADDRESS LOCATED IN R3//
  J		xcounter_of_pressed_kesys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
  ADDI	R3,R3,07
  //PUTTING R3=7 AS THIS IS THE INITIAL VALUW OF '4' BUTTON//
  SW	R3,R3	
  //STORING THE VALUE OF R4 IN THE MEMORY ADDRESS LOCATED IN R3//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
  ADDI	R3,R3,010
  //PUTTING R3=10 AS THIS IS THE INITIAL VALUE OF '5' BUTTON//
  SW	R3,R4
  //STORE THE VALUE OF R4 IN THE MEMORY ADDRESS LOCATED IN R3//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
  ADDI	R3,R3,013
  //PUTTING R3=13 AS THIS IS THE INITIAL VALUE OF '6' BUTTON//
  SW	R3,R4
  //STORING THE VALUE OF R3 IN MEMORY ADDRESS LOCATED IN R4//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
  ADDI R3,R3,016
  //PUTTING R3=16 AS THIS IS THE INITIAL VALUE OF '7' BUTTON//
  SW	R3,R4 
  //STORING THE VALUE OF R4 IN MEMORY ADDRESS LOCATED IN R3//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
  ADDI	R3,R3,020
  //PUTTING R3=20 AS THIS IS THE INITIAL VALUE OF '8' BUTTON//
  SW	R3,R4
  //STORING THE VALUE OF R4 IN MEMORY ADDRESS LOCATED IN R3//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
  ADDI	R3,R3,023
  //PUTTING R3=23 AS THIS IS THE INITIAL VALUE OF '9' BUTTON//
  SW	R3,R4
  //STORING THE VALUE OF R3 IN MEMORY ADDRESS LOCATED IN R4//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
  
  //******************************************************************************//
 *Engineer:       Youssef Taha 
 * Create date:   23:08:22 04/07/2020
 * MACROS Name:   ADJUST_CURSOR & PRINT_DOT & LOAD_R1
 * Description:   ADJUST_CURSOR : MOVING THE CURSOR TO THE R1,R2 coordinates
                  PRINT_DOT     : PRINTING DOTS
				  LOAD_R1       : LOADING R1 WITH THE DATA IN M[21]
			
                  
// *******************************************************************************//
 
 //MACRO THAT IS RESPONSIBLE FOR MOVING THE CURSOR TO ANY PLACE
 IN LCD JUST PUT THE ROW IN R1,COLUMN IN R2 //
 
 xADJUST_CURSOR:NOP
 SUB	R3,R3,R3
 SUB	R4,R4,R4
 ADDI	R3,R3,011
 ADDI	R4,R4,012
 SW		R1,R3
 SW		R2,R4
 J 	    xLCD_goToRowColumn
 
 //**************************************************************************//
 
 //MACRO THAT IS RESPONSIBLE FOR GETTING THE ASCII CODE OF DOT IN M[21]
 AND PRINT IT //
 
 xPRINT_DOT:NOP
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R2,022
 LW		R1,R2
 SUB	R2,R2,R2
 ADDI	R2,R2,010
 SW		R1,R2
 J	    xLCD_displayCharacter 
 
 //***************************************************************************//
 
 //MACRO THAT IS RESPONSIBLE FOR LOADING R1 WITH DATA IN M[21]//
 
 xLOAD_R1:NOP
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R2,R2,021
 LW		R1,R2
 JR		R7
 
 //****************************************************************************//
 
//-------------------------------------------------------------------------------------------------------//

//******************************************************************************
 * Engineer:      Yahya Hamdy
 * Create date:   1:16:17 06/04/2020
 * Function Name: xCounter_Of_Pressed_Keys
 * Description:  Converting the input to a value poinnting at the 
                 number of the wanted alphapetic letter as the used assembler 
		 is not supporting an immediate value more than 031
 * Inputs:        Data to be printed and initial value of the counter
 * Outputs:       New value of the counter that points at the number 
                  of the wanted alphapetic letter
 *******************************************************************************//
xCounter_Of_Pressed_Keys:NOP
//Clear Registers R1,R2,R3,R4//
SUB R1,R1,R1
SUB R2,R2,R2
SUB R3,R3,R3
SUB R4,R4,R4

//Setting R3,R4 with the values of the input and counter initial value memory locations//
ADDI R3,R3,020
ADDI R4,R4,021

//Storing the entered value in R1 and the initial value of the counter in R2//
LW R1,R3
LW R2,R4 

//Shift Right R1 by 4 bits and storing the shifted value in R3//
SUB R3,R3,R3
SRL R3,R1
SRL R3,R3
SRL R3,R3
SRL R3,R3

//Jump to the display procedure after reading the input successfully and keeping the value of the counter unchanged//
ANDI R3,R3,015
SUB R4,R4,R4
BEQ R3,R4,#OFFSET

//The key is pressed again so the value of the counter will be incremented//
ADDI R2,R2,01

//Store the new value of the counter in memory//
SUB R3,R3,R3
ADDI R4,R4,021
SW R2,R4

//Read the next nibble and check if the key is pressed again//
SRL R3,R1
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
ANDI R3,R3,015
SUB R4,R4,R4
BEQ R3,R4,#OFFSET
ADDI R2,R2,01
SUB R3,R3,R3
ADDI R4,R4,021
SW R2,R4

//Read the next nibble and check if the key is pressed again//
SRL R3,R1
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
ANDI R3,R3,015
SUB R4,R4,R4
BEQ R3,R4,#OFFSET
ADDI R2,R2,01
SUB R3,R3,R3
ADDI R4,R4,021
SW R2,R4

//The input is read successfully , Jump to the display procedure//
J xSend_"YOU ENTERD"_Message
//-------------------------------------------------------------------------------------------------------------------------------------//
//***********************************************
*Engineer        : Mohamed Ammar
*Creat date      : 6/4/2020 
*Edited          : 7/4/2020
*Function name   : Send_"YOU ENTERD"_Message
*Description     : A function to print string 

***********************************************//

 xSend_"YOU ENTERD"_Message

 // PRINTING Y //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,29
 ADDI R2,R2,10
 SW   R1,R2

 // GOTO ROW 1 // 
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADDI R1,R1,1
 ADDI R2,R2,11
 SW   R1,R2
 
 //GOTO COL1 //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADDI R1,R1,1
 ADDI R2,R2,12
 SW   R1,R2
 
 JAL xLCD_goToRowColumn
 JAL xLCD_displayCharacter 
 
 // PRINTING O //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,19
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 

 // PRINTING U //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,25
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 
 
 // PRINTING SPACE //
 SUB  R1,R1,R1  
 SUB  R2,R2,R2
 ADDI R1,R1,30
 ADDI R1,R1,2
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 
 
 // PRINTING E //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,9
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter

 // PRINTING N //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,18
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter

 // PRINTING T //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,24
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter

 // PRINTING E //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,9
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 

 // PRINTING R //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,22
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter

 // PRINTING E //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,9
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 

 // PRINTING D //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,8
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter

 // PRINTING : //
 SUB  R1,R1,R1  
 SUB  R2,R2,R2
 ADDI R1,R1,30
 ADDI R1,R1,28
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 
 
 // PRINTING SPACE //
 SUB  R1,R1,R1  
 SUB  R2,R2,R2
 ADDI R1,R1,30
 ADDI R1,R1,2
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 
 

 // ASCII CODE OF REQUIRED LETTER //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADDI R2,R2,21
 LW   R1,R2
 ADDI R1,R1,30 
 ADDI R1,R1,30
 ADDI R1,R1,4

 //  PRINTING THE LETTER  //
 SUB  R2,R2,R2
 ADDI R2,R2,10
 SW   R1,R2 
 JAL xLCD_displayCharacter 
//-------------------------------------------------------------------------------------------------------------------------------------// 
 //******************************************************************************
 * Engineer:      Mohamed AMMAR & YAHYA HAMDY & YOUSSEF TAHA
 * Create date:   23:08:22 04/07/2020
 * Function Name: PRINT_BRAILLE_CHARACTER
 * Description:   A function that's responsible for converting the character 
                  to braille language
 *     
 * Inputs:        The Character Number
 * Outputs:       void
 *******************************************************************************//
 
 //PUTTING DOT ASCII IN M[22]//
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,030
 ADDI	R1,R1,016
 ADDI	R2,R2,022
 SW		R1,R2

 //****************************************************************************//
 //THE VALUE OF THE CHARACTER STORED IN M[21] SO WE LOAD R1 WITH M[21]
   ,COMPARE THE CHARACTER NUMBER WITH ALL CHARACTERS NUMBERS IF THERE IS A MATCH 
   WE PRINT THE CHARACTER IN BRAILLE LANGUAGE //
 //****************************************************************************//
 
 xCHECK_A:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,01
 
 //IF THE CHARACTER IS 'A' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
   TO THE 'A' DRAWING LINES OF CODE IF IT ISN'T 'A' WE JUMP TO NEXT LINE OF BEQ 
   WHICH IS CHECK_B//
   
 BEQ	R1,R2,02
 J		xCHECK_B
 
 // 'A' DRAWING LINE OF CODE THAT PRINT A IN BRAILLE
     ". "//
 
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_B:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,02
 
  //IF THE CHARACTER IS 'B' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
   TO THE 'B' DRAWING LINES OF CODE IF IT ISN'T 'B' WE JUMP TO NEXT LINE OF BEQ 
   WHICH IS CHECK_C//
   
 BEQ 	R1,R2,02
 J		xCHECK_C
 
  // 'B' DRAWING LINES OF CODE THAT PRINT 'B' IN BRAILLE
     ". "
     ". "//
 
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_C:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,03
 
   //IF THE CHARACTER IS 'C' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
   TO THE 'C' DRAWING LINES OF CODE IF IT ISN'T 'C' WE JUMP TO NEXT LINE OF BEQ 
   WHICH IS CHECK_D//
   
 BEQ	R1,R2,02
 J		xCHECK_D
 
   // 'C' DRAWING LINES OF CODE THAT PRINT 'C' IN BRAILLE
      ". ."
      "   "//
 
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_D:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,04
 
    //IF THE CHARACTER IS 'D' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
   TO THE 'D' DRAWING LINES OF CODE IF IT ISN'T 'D' WE JUMP TO NEXT LINE OF BEQ 
   WHICH IS CHECK_E//
   
 BEQ	R1,R2,x02
 J		xCHECK_E
 
    // 'D' DRAWING LINES OF CODE THAT PRINT 'D' IN BRAILLE
        ". ."
        "  ."//
 
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_E:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R1,R1,05
 
    //IF THE CHARACTER IS 'E' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
   TO THE 'E' DRAWING LINES OF CODE IF IT ISN'T 'E' WE JUMP TO NEXT LINE OF BEQ 
   WHICH IS CHECK_F//
   
 BEQ	R1,R2,02
 J		xCHECK_F
 
     // 'D' DRAWING LINES OF CODE THAT PRINT 'D' IN BRAILLE
        ".  "
        "  ."//
 
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_F:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,06
 
   //IF THE CHARACTER IS 'F' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
   TO THE 'F' DRAWING LINES OF CODE IF IT ISN'T 'F' WE JUMP TO NEXT LINE OF BEQ 
   WHICH IS CHECK_G//
   
 BEQ	R1,R2,02
 J		xCHECK_G
 
      // 'F' DRAWING LINES OF CODE THAT PRINT 'F' IN BRAILLE
          ". ."
          "  ."//
 
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_G:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,07
 
    //IF THE CHARACTER IS 'G' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'G' DRAWING LINES OF CODE IF IT ISN'T 'G' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_H//
   
 BEQ	R1,R2,02
 J		xCHECK_H
 
       // 'G' DRAWING LINES OF CODE THAT PRINT 'G' IN BRAILLE
          ". ."
          ". ."//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT

xCHECK_H:NOP
 JAL	xLOAD_R1
 SUB	R2,R,R2
 ADDI	R2,R2,08
 
     //IF THE CHARACTER IS 'H' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'H' DRAWING LINES OF CODE IF IT ISN'T 'H' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_I//
	  
 BEQ	R1,R2,02
 J		xCHECK_I
 
       // 'H' DRAWING LINES OF CODE THAT PRINT 'H' IN BRAILLE
          ".  "
          ". ."//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT

 xCHECK_I:NOP
  JAL	xLOAD_R1
 SUB	R2,R,R2
 ADDI	R2,R2,09
      //IF THE CHARACTER IS 'I' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'I' DRAWING LINES OF CODE IF IT ISN'T 'I' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_J//
	  
 BEQ	R1,R2,02
 J		xCHECK_J
 
        // 'I' DRAWING LINES OF CODE THAT PRINT 'I' IN BRAILLE
          "  ."
          ".  "//
 
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_J:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,010
 
    //IF THE CHARACTER IS 'J' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'J' DRAWING LINES OF CODE IF IT ISN'T 'J' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_K//
   
 BEQ	R1,R2,02
 J		xCHECK_K
 
       // 'J' DRAWING LINES OF CODE THAT PRINT 'J' IN BRAILLE
          "  ."
          ". ."//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_K:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,011
 
    //IF THE CHARACTER IS 'K' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'K' DRAWING LINES OF CODE IF IT ISN'T 'K' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_L//
   
 BEQ	R1,R2,02
 J		xCHECK_L
 
       // 'K' DRAWING LINES OF CODE THAT PRINT 'K' IN BRAILLE
          ".  "
          "   "
          ".  "//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_L:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,012
 
    //IF THE CHARACTER IS 'L' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'L' DRAWING LINES OF CODE IF IT ISN'T 'L' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_M//
   
 BEQ	R1,R2,02
 J		xCHECK_M
 
       // 'L' DRAWING LINES OF CODE THAT PRINT 'L' IN BRAILLE
          ".  "
          ".  "
          ".  "//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_M:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,013
 
    //IF THE CHARACTER IS 'M' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'M' DRAWING LINES OF CODE IF IT ISN'T 'M' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_N//
   
 BEQ	R1,R2,02
 J		xCHECK_N
 
       // 'M' DRAWING LINES OF CODE THAT PRINT 'M' IN BRAILLE
          ". ."
          "   "
          ".  "//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_N:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,014
 
    //IF THE CHARACTER IS 'N' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'N' DRAWING LINES OF CODE IF IT ISN'T 'N' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_O//
   
 BEQ	R1,R2,02
 J		xCHECK_O
 
       // 'N' DRAWING LINES OF CODE THAT PRINT 'N' IN BRAILLE
          ". ."
          "  ."
          ".  "//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_O:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,015
 
    //IF THE CHARACTER IS 'O' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'O' DRAWING LINES OF CODE IF IT ISN'T 'O' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_P//
   
 BEQ	R1,R2,02
 J		xCHECK_P
 
       // 'O' DRAWING LINES OF CODE THAT PRINT 'O' IN BRAILLE
          ".  "
          "  ."
          ".  "//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_P:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,016
 
    //IF THE CHARACTER IS 'P' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'P' DRAWING LINES OF CODE IF IT ISN'T 'P' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_Q//
   
 BEQ	R1,R2,02
 J		xCHECK_Q
 
       // 'P' DRAWING LINES OF CODE THAT PRINT 'P' IN BRAILLE
          ". ."
          ".  "
          ".  "//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
  xCHECK_Q:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,017
 
    //IF THE CHARACTER IS 'Q' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'Q' DRAWING LINES OF CODE IF IT ISN'T 'Q' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_R//
   
 BEQ	R1,R2,02
 J		xCHECK_R
 
       // 'Q' DRAWING LINES OF CODE THAT PRINT 'Q' IN BRAILLE
          ". ."
          ". ."
          ".  "//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_R:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,018
 
    //IF THE CHARACTER IS 'R' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'R' DRAWING LINES OF CODE IF IT ISN'T 'R' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_S//
   
 BEQ	R1,R2,02
 J		xCHECK_S
 
       // 'R' DRAWING LINES OF CODE THAT PRINT 'R' IN BRAILLE
          ".  "
          ". ."
          ".  "//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_S:NOP
 
 
 //****************************************************************************//
 
//-------------------------------------------------------------------------------------------------------//

//******************************************************************************
*Engineer        : Reem Saleh
*Create date      : 10:10:26 8/4/2020 
*Function name   : xLCD_init
*Description     : Initialize the LCD internal registers and configure LCD Data/Control pins
xLCD_init:
// putting R0=R1=R2=0 //
 SUB  R0,R0,R0 
 SUB  R1,R1,R1
 SUB  R2,R2,R2
// Sending Command 38H, 8 bit mode //
 // RS=RW=0 --->  R0 AND 0b1110011111111111 //
  // Creating the bitmask 0b1110011111111111 //
   ADDI R1,R1,7
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   OR   R2,R2,R1
   SUB  R1,R1,R1
   ADDI R1,R1,7
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   OR   R2,R2,R1
   SUB  R1,R1,R1
   ADDI R1,R1,15
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   ADDI R1,R1,15
   OR   R2,R2,R1
   AND  R0,R0,R2
   OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // E=1 --->  R0 OR 0b0000010000000000 //
  SUB  R1,R1,R1
  ADDI R1,R1,1
  SLL R1,R1
  SLL R1,R1
  SLL R1,R1
  SLL R1,R1
  SLL R1,R1
  SLL R1,R1
  SLL R1,R1
  SLL R1,R1
  SLL R1,R1
  SLL R1,R1
  OR  R0,R1
  OUT R0
  // Delay for 1ms //
   SUB  R1,R1,R1
   ADDI R1,R1,18
   SW   R7,R1
   JAL  XDelay 
   SUB  R1,R1,R1
   ADDI R1,R1,18
   LW   R7,R1
 // Command = 38H ---> R0 OR 0b0000000011100000 //
  // Creating the bitmask 0b0000000011100000 //  
   SUB  R1,R1,R1
   ADDI R1,R1,7
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   OR   R0,R1
   OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // E=0 --->  R0 AND 0b1111101111111111 //
  SUB  R1,R1,R1
  SUB  R2,R2,R2
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,01
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  ADDI R1,03
  OR   R2,R1
  AND  R0,R2
  OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
// Sending Command 0FH, Display on cursor blinking // 
 // RS=RW=0 --->  R0 AND 0b1110011111111111 //
  // Creating the bitmask 0b1110011111111111 //
   SUB  R1,R1,R1 
   ADDI R1,R1,7
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   OR   R2,R2,R1
   SUB  R1,R1,R1
   ADDI R1,R1,7
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   OR   R2,R2,R1
   SUB  R1,R1,R1
   ADDI R1,R1,15
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   ADDI R1,R1,15
   OR   R2,R2,R1
   AND  R0,R0,R2
   OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // E=1 --->  R0 OR 0b0000010000000000 //
  SUB  R1,R1,R1
  ADDI R1,R1,1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R0,R1
  OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // Command = 0FH ---> R0 OR 0b0000000000111100 //
  SUB  R1,R1,R1
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  OR   R0,R1
  OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // E=0 --->  R0 AND 0b1111101111111111 //
  SUB  R1,R1,R1
  SUB  R2,R2,R2
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,01
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  ADDI R1,03
  OR   R2,R1
  AND  R0,R2
  OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
// Sending Command 01H, Clear Screen // 
 // RS=RW=0 --->  R0 AND 0b1110011111111111 //
  // Creating the bitmask 0b1110011111111111 //
   SUB  R1,R1,R1 
   ADDI R1,R1,7
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   OR   R2,R2,R1
   SUB  R1,R1,R1
   ADDI R1,R1,7
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   OR   R2,R2,R1
   SUB  R1,R1,R1
   ADDI R1,R1,15
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   ADDI R1,R1,15
   OR   R2,R2,R1
   AND  R0,R0,R2
   OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // E=1 --->  R0 OR 0b0000010000000000 //
  SUB  R1,R1,R1
  ADDI R1,R1,1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R0,R1
  OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // Command = 01H ---> R0 OR 0b0000000000000100 //
  SUB  R1,R1,R1
  ADDI R1,R1,01
  SLL  R1,R1
  SLL  R1,R1
  OR   R0,R1
  OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // E=0 --->  R0 AND 0b1111101111111111 //
  SUB  R1,R1,R1
  SUB  R2,R2,R2
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,01
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  ADDI R1,03
  OR   R2,R1
  AND  R0,R2
  OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
// Sending Command 06H, Entery mode, auto increment with no shift // 
 // RS=RW=0 --->  R0 AND 0b1110011111111111 //
  // Creating the bitmask 0b1110011111111111 //
   SUB  R1,R1,R1 
   ADDI R1,R1,7
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   OR   R2,R2,R1
   SUB  R1,R1,R1
   ADDI R1,R1,7
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   OR   R2,R2,R1
   SUB  R1,R1,R1
   ADDI R1,R1,15
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   ADDI R1,R1,15
   OR   R2,R2,R1
   AND  R0,R0,R2
   OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // E=1 --->  R0 OR 0b0000010000000000 //
  SUB  R1,R1,R1
  ADDI R1,R1,1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R0,R1
  OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // Command = 06H ---> R0 OR 0b0000000000011000 //
  SUB  R1,R1,R1
  ADDI R1,R1,3
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R0,R1
  OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // E=0 --->  R0 AND 0b1111101111111111 //
  SUB  R1,R1,R1
  SUB  R2,R2,R2
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,01
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  ADDI R1,03
  OR   R2,R1
  AND  R0,R2
  OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
// Clearing The Registers used in the function (R0,R1,R2,R3) //
 SUB  R0,R0,R0
 SUB  R1,R1,R1
 SUB  R2,R2,R2
JR   R7 