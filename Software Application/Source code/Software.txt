//******************************************************************************
 * Engineer:      Hesham Khaled
 * Create date:   23:08:22 04/04/2020
 * Function Name: LCD_goToRowColumn
 * Description:   A function that's responsible for moving LCD's cursor
 *                to a specific position.
 * Inputs:        Decimal Values for Row and Column
 * Outputs:       void
 *
 // *****************************************************************************//
xLCD_goToRowColumn: NOP
 // Putting R0=0, Storing in R0 the Memory address of the Row to go
    SUB  R0,R0,R0
    ADDI R0,R0,11
 // Putting R1=0, Storing in R1 the Memory address of the Column to go
    SUB  R1,R1,R1
    ADDI R1,R1,12
 // Storing the value of the Row in R0, Value of Column in R1
 // Making R2=0 as initial value and the index
    LW   R0,R0
    LW   R1,R1
    SUB  R2,R2,R2
 // Checking if it is Row (0), If yes, Jump, if no, add the index+1
    BEQ  R0,R2,09
    ADDI R2,R2,01
 // Checking if it is Row (1), If yes, Jump, if no, add the index+1
    BEQ  R0,R2,08
    ADD  R2,R2,R2
 // Checking if it is Row (2), If yes, Jump, if no, it must be Row (3)
    BEQ  R0,R2,11
 // Position Address @ Row(3) = Column + 0x50 (80 Decimal)
    ADDI R1,R1,20
    ADD  R1,R1,20
    ADD  R1,R1,20
    ADD  R1,R1,20
    J    xEND
 // Position Address @ Row(0) = Column //
    J    xEND
 // Position Address @ Row(1) = Column+0x40 (64 Decimal)
    ADDI R1,R1,20
    ADDI R1,R1,20
    ADDI R1,R1,20
    ADDI R1,R1,04
    J    xEND
 // Position Address @ Row(2) = Column+0x10 (16 Decimal)
    ADDI R1,R1,16

 // R1= Address of the required position to go to.
   1. In this label, I am setting the command to be sent
    as, Command = Address OR 0b0000000010000000
   2. and calling the command function

xEND: NOP
 // 1.First step (Command = Address OR 0b0000000010000000)
    SUB  R0,R0,R0
    ADDI R0,R0,01
    SLL  R0,R0
    SLL  R0,R0
    SLL  R0,R0
    SLL  R0,R0
    SLL  R0,R0
    SLL  R0,R0
    SLL  R0,R0
    OR   R1,R1,R0
 // 2.   Second step (Calling Command Function)
 // 2.A: Storing Command in M[10]
 // 2.B: Storing Main Procedure return address (R7) in M[19] 
 // 2.C: Re-Storing Main Procedure return M[19] in (R7)
    SUB  R0,R0,R0
    ADDI R0,R0,10
    SW   R1,R0
    ADDI R0,R0,09
    SW   R7,R0
    JAL  xLCD_sendCommand
    SUB  R0,R0,R0
    ADDI R0,R0,19
    LW   R7,R0
 // Clearing used Registers (R0,R1,R2)
    SUB  R0,R0,R0
    SUB  R1,R1,R1
    SUB  R2,R2,R2
    JR R7
    
//******************************************************************************
 * Engineer:      Youssef Galal
 * Create date:   22:01:17 04/04/2020
 * Function Name: LCD_displayCharacter
 * Description:   takes the 8-bit value stored in a FIXED Memory Location
 *                to a specific position.
 * Inputs:        Data to be printed
 * Outputs:       void
 *
 *******************************************************************************//
//Function Discription: takes the 8-bit value in a FIXED address//
//and displays it on the LCD// 
//Name: Youssef Galal//
//Note: This file format is "*code* then a comment"//
xLCD_displayCharacter:
    SUB R1,R1,R1
    //putting R1=0//
    SUB R2,R2,R2 
    //putting R2=0//
    NOR R1,R1,R1
    // 0 NOR 0 = 1 so R1= 1111 1111 1111 1111//
    NOR R2,R2,R2
    // 0 NOR 0 = 1 so R2= 1111 1111 1111 1111//
    SRL R2,R2
    // R2 =  0111 1111 1111 1111//
    XOR R1,R1,R2
    // R1 = 1000 0000 0000 0000//
    SRL R1,R1
    // R1 = 0100 0000 0000 0000//
    SRL R1,R1
    // R1 = 0010 0000 0000 0000//
    SRL R1,R1
    // R1 = 0001 0000 0000 0000//      
    IN R4
    //R4 = Getting the other 5 bits for masking//
    SRL R2,R2
    //R2 = 0011 1111 1111 1111 //
    SRL R2,R2
    //R2 = 0001 1111 1111 1111 //
    NOR R2,R2,R2
    //R2 = 1110 0000 0000 0000//
    ADDI R2,R2,03
    //R2 = 1110 0000 0000 0011//    
    AND R4,R4,R2
    //Masking operation //
    //R4 = nnn0 0000 0000 00nn//
    // "n" represents a bit that we don't use in the LCD//
    OR R4,R1,R4 
    //R4 now = nnn1 0000 0000 00nn//
    OUT R4         
    // makes RS bit = 1 "Data mode"//
    // and RW bit =0 "Write data" // 
    SUB R0,R0,R0
    OR R0,R0,R7
    JAL xDelay
    // we must wait for the LCD to get it//
    SRL R4,R1
    SRL R4,R1 
    //R4 = 0000 0100 0000 0000//
    OR R1,R1,R4
    //R1 = 0001 0100 0000 0000//  
    IN R4
    //R4 = Getting the first 5 bits for masking/
    AND R4,R4,R2
    //R4 = nnn0 0000 0000 00nn//
    // "n" represents a bit that we don't use in the LCD//
    OR R4,R1,R4 
    // R4 = nnn1 0100 0000 00nn//
    OUT R4          
    // makes E bit = 1//
    JAL xDelay
    SUB R3,R3,R3
    // cleaning R3 = 0//
    ORI R3,R3,10  
    // The data is stored in a fixed address = 10// 
    // R3 now has the address for my data//
    LW R3,R3
    // R3 now = 8-bit data //
    SLL R3,R3
    SLL R3,R3
    // R3 = 0000 00da tada ta00//
    OR R3,R1,R3
    // R1 = 0001 0100 0000 0000//
    // R3 = 0000 00da tada ta00//
    // OR op. -> R3 = 0001 01da tada ta00//
    IN R4
    //R4 = Getting the first 5 bits for masking//
    AND R4,R4,R2
    // R4 = nnn0 0000 0000 00nn//
    OR R3,R3,R4 
    // R3 = nnn1 01da tada tann// 
    OUT R3
    // showing the data on LCD //
    JAL xDelay
    //R2 = 1110 0000 0000 0011//
    //R1 = 0001 0100 0000 0000//
    SLL R1,R1
    SLL R1,R1
    AND R1,R1,R2
    // R1 = 0001 0000 0000 0000//
    IN R4
    //R4 = Getting the first 5 bits for masking//
    AND R4,R4,R2
    //R4 = nnn0 0000 0000 00nn//
    OR R4,R1,R4 
    // R4 = nnn1 0000 0000 00nn//
    OUT R4        
    // R4 value clears E //
    JAL xDelay
    SUB R7,R7,R7
    //clearing the address in R7//
    OR R7,R7,R0
    //getting the address of the main to return to it//
    SUB R0,R0,R0
    SUB R1,R1,R1
    SUB R2,R2,R2
    SUB R3,R3,R3
    SUB R4,R4,R4
    //all registers used here = 0 after we return from this function//
JR R7

// assumption of how the LCD is connected to the o/p port//
// if there is any change contact me//
//  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 //  
//  0  0  0  RS RW E  0  1  2  3  4  5  6  7  0  0  //


//Discription: this code creates 250000 and stores it in address 30//
//excute it in the main code//
//this block uses only R5 and R6 from regfile//
//Name: Youssef Galal//
SUB R6,R6,R6
SUB R5,R5,R5
//R6=0 R5=0//
ADDI R5,R5,30   
// Address 25//
ADDI R6,R6,24   
//     0000 0000 0001 1000//
SRL R6,R6       
//     0000 0000 0011 0000//
SRL R6,R6      
//     0000 0000 0110 0000//
SRL R6,R6       
//     0000 0000 1100 0000//
SRL R6,R6       
//     0000 0001 1000 0000//
SRL R6,R6       
//     0000 0011 0000 0000//
ADDI R6,R6,13   
//     0000 0011 0000 1101//
SRL R6,R6       
//     0000 0110 0001 1010//
SRL R6,R6       
//     0000 1100 0011 0100//
ADDI R6,R6,01   
//     0000 1100 0011 0101//
SRL R6,R6       
//     0001 1000 0110 1010//
SRL R6,R6       
//     0011 0000 1101 0100//
SRL R6,R6       
//     0110 0001 1010 1000//
SW R6,R5        
//     25000 IS STORED IN ADDRESS 30//
SUB R6,R6,R6
SUB R5,R5,R5
// R6=0 R5=0//
//END OF THE BLOCK//


//Function Discription: Delays for 1ms//
//assuming that the clock used is 25MHz,1 cycle takes 40ns//
//counter = 1ms/40ns = 25000 counts //
//25000 is stored by default in address 25d //
//Name: Youssef Galal//
xDelay:
    SUB R5,R5,R5
    SUB R6,R6,R6
    //R6=0,R5=0//
    ADDI R6,R6,30
    //having the address 25 in R6//
    LW R6,R6
    //loading data from address 25 in R6//
    xLoop:
        ADDI R5,R5,01
        //R5 accumulates untill it reaches 250000//
        NOP
        BEQ R5,R6,01
        //if R5 reaches R6 "25000" we will skip the jump line//
        J xLoop
        //if R5 doesn't reach R6 "25000" we will go to xLoop again//
    SUB R5,R5,R5
    SUB R6,R6,R6
    //getting out of the function and cleaning R5,R6//
    JR R7

// end of Galal's part//

//******************************************************************************/
 * Engineer:      Asmaa Sameh
 * Create date:     07/04/2020
 *Function Name: LCD_sendCommand
 *Description: Sends a certain command to the LCD through the LCD’s control pins
 *Inputs: Decimal value for command number
 *Return: void
 *
 *****************************************************************************//
//  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 //  
//  0  0  0  RS RW E  0  1  2  3  4  5  6  7  0 0 //

xLCD_sendCommand: NOP
SUB R1,R1,R1
// RS=0   RW=0//
ORI R1,R1,03h
// R1 = 0000 0000 0000 0011//
SUB R2,R2,R2
ORI R2,R2,07h
//R2 = 0000 0000 0000 0111//
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
//R2 = 1110 0000 0000 0000//
OR R1,R2,R1
//R1= 1110 0000 0000 0011//

SUB R2,R2,R2

IN R6 
AND R2,R1,R6

// R2 have 5-Bit masking //
// RS=0   RW=0//

 SUB R0,R0,R0
ORI R0,R0,18h
SW R0,R7

JAL xDelay 

SUB R3,R3,R3
ORI R3,R3,10
// data is stored in fixed address=10//
// address is stored in R3//
LW R3,R3
//R3 is the command now//
// R3 = 0000 0000 CMD CMD//
SLL R3, R3
SLL R3,R3
// R3= 0000 00 CMD CMD 00// 

OR R2,R3,R2
//R2= 5-bit masking + CMD value //

SUB R0,R0,R0
ORI R0,R0,15h
SW R0,R1
// Store value of R1 in memory location 15//

SUB R0,R0,R0
ORI R0,R0,16h
SW R0,R2
// Store value of R2 in memory location 16//

SUB R0,R0,R0
ORI R0,R0,17h
SW R0,R3
// Store value of R3 in memory location 17//


J xCmp1
J xCmp2
JAL xLCD_goToRowColumN

SUB R0,R0,R0
ORI R0,R0,15h
LW R1,R0

SUB R0,R0,R0
ORI R0,R0,16h
LW R2,R0

SUB R0,R0,R0
ORI R0,R0,17h
LW R3,R0
// put values in their regs again from memo// 

JAL xDelay

SUB R4,R4,R4
SUB R5,R5,R5
NOR R4,R4,R4
//R4= FFFF //
NOR R5,R5,R5
//R5= FFFF//
SRL R4,R4
// R4= 7FFF //
XOR R4,R5,R4
//R4= 1000 0000 0000 0000//
SRL R4,R4
SRL R4,R4
SRL R4,R4
SRL R4,R4
SRL R4,R4
// R4 = 0000 0100 0000 0000 //
OR R2,R4,R2
// E=1 //

OUT R2 
 
JAL xDelay 

IN R6 
AND R1,R6,R1
// R1=1110 0000 0000 0011//
// 5- bit masking connected //
AND R2,R1,R2

OUT R2
// E=0//


JAL xDelay



SUB R7,R7,R7
OR R7,R7,18h
LW R7,R7

JR R7

xCmp1: NOP
SUB R0,R0,R0
ADDI R0,R0,01
BEQ R3,R0,R3
JAL xClear_LCD 
JR7
// compare value of CMD by 01 ( clear fun)//

xCmp2: NOP 
SUB R0,R0,R0
ADDI R0,R0,02
BEQ R3,R0,R3
JAL xIni_LCD
JR7
// compare value of CMD by 02 (inti fun)//
//-------------------------------------------------------------------------------------------//
//*********************************************************************************
*Engineer: Toka Zakaria
* Create date:    14/04/2020
*Function name: LCD_clearScreen
*Description: clear LCD screen entirely and moves the cursor to the initial position.
*Inputs: void
*Outputs: void
***********************************************************************************//
xLCD_clearScreen:
//make R1=0 , R2=0 , R3=0//
SUB R1,R1,R1
SUB R2,R2,R2
SUB R3,R3,R3
// (1) make Rs=0 & Rw=0 to make the LCD waits for certain command//
//to make that, sending the value of R1 after editing it as follow R1 AND 0b1110011111111111 to keep other pins as they are//
//1st create 0b1110011111111111//
ADDI R2,R2,07
SLL R2,R2 
SLL R2,R2 
SLL R2,R2 
SLL R2,R2 
SLL R2,R2 
SLL R2,R2 
SLL R2,R2 
SLL R2,R2 
SLL R2,R2 
SLL R2,R2 
SLL R2,R2 
SLL R2,R2 
SLL R2,R2 
OR R3,R3,R2
SUB R2,R2,R2
ADDI R2,R2,07
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
OR R3,R3,R2
SUB R2,R2,R2
ADDI R2,R2,15
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
ADDI R2,R2,15
//R3=1110011111111111//
OR R3,R3,R2
AND R1,R1,R3
//Rs=0//
OUT R1
//wait for one MS using Delay function//
//storing the data in R7 in R2 at first//
SUB R2,R2,R2
//storing memory location in R2 ‘selecting address [16]’//
ADDI R2,R2,16
SW R7,R2
JAL xDelay
//return data to R7 again//
SUB R2,R2,R2 
ADDI R2,R2,16
LW R7,R2
//(2)make the Enable high ‘E=1’ //
//to make that …. R1 OR 0b0000010000000000//
//create 0b000001000000000//
SUB R2,R2,R2
ADDI R2,R2,01
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
OR R1,R2
//E=1//
OUT R1
//wait for one MS using delay function//
//storing the data in R7 in R2 at first//
SUB R2,R2,R2
//storing memory location in R2 ‘selecting address [16]//
ADDI R2,R2,16
SW R7,R1
JAL xDelay
//return data to R7 again//
SUB R2,R2,R2 
ADDI R2,R2,16
LW R7,R2
//Rs=0 & E=1 , now LCD ready to receive a command//
//sending command 01H to the LCD to clear display screen//
// R1 OR 0b0000000000000100//
//create 0b0000000000000100//
SUB R2,R2,R2
ADDI R2,R2,01
SLL R2,R2
SLL R2,R2
OR R1,R2
OUT R1
//wait for 1 MS using delay function//
//storing the data in R7 in R2 at first//
SUB R2,R2,R2
//storing memory location in R2 ‘selecting address [16]//
ADDI R2,R2,16
SW R7,R1
JAL xDelay
//return data to R7 again//
SUB R2,R2,R2 
ADDI R2,R2,16
LW R7,R2
//make the Enable low again ‘E=0’//
//to make that, R1 AND 0b1111101111111111//
SUB R2,R2,R2
SUB R3,R3,R3
ADDI R2,R2,15
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
OR R3,R1
SUB R2,R2
ADD R2,R2,01
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
ADDI R2,R2,15
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
SLL R2,R2
OR R3,R2
SUB R2,R2
ADDI R2,R2,15
SLL R2,R2
SLL R2,R2
ADDI R2,03
OR R3,R2
// R3= 0b1111101111111111//
AND R1,R3
// E=0//
OUT R1
//clearing the Rsgs that are used in the function//
SUB R1,R1,R1
SUB R2,R2,R2
SUB R3,R3,R3
// return to main//
JR R7
//--------------------------------------------------------------------------------------------------------//
//***********************************************
*Engineer        : Mena Emiel
*Create date     : 7/4/2020 
*Function name   : Store_PressedKey
*Description     : Store value of the pressed key from the keypad
***********************************************//
xStore_PressedKey:
JAL  xKeypad_GetPressedKey
//Clear the registers//
SUB  R1,R1,R1
SUB  R2,R2,R2
SUB  R3,R3,R3
SUB  R4,R4,R4
//Load the Value of the pressed key from the memory location M[00]//
ADDI R4,R4,000
LW   R1,R4
//R4=0, Sending the stored value from R1 to the memory location M[20]//
SUB  R4,R4,R4
ADDI R4,R4,020
SW   R1,R4
//Getting the pressed key which is '*' or '#'//
xCheckInput:
JAL  xKeypad_GetPressedKey
//Clear the registers//
SUB  R1,R1,R1
SUB  R2,R2,R2
SUB  R3,R3,R3
SUB  R4,R4,R4
//Store the value of '*' in R3//
ADDI R3,R3,00
//Load the previous value of the pressed key from M[20] to R1//
ADDI R4,R4,020
LW   R1,R4
//R4=0, Check if the user pressed '*'//
SUB  R4,R4,R4
ADDI R4,R4,000
LW   R2,R4
BEQ  R2,R3,02
J    xHashtag_Pressed
//if the user pressed '*', shifting the register value to store next pressed key//
SRL  R1,R1
SRL  R1,R1
SRL  R1,R1
SRL  R1,R1
//R4=0, Sending the stored value from R1 to the memory location M[20]//
SUB  R4,R4,R4
ADDI R4,R4,020
SW   R1,R4
//Getting the pressed key after the '*'//
JAL  xKeypad_GetPressedKey
//Clear the registers//
SUB  R1,R1,R1
SUB  R2,R2,R2
SUB  R3,R3,R3
SUB  R4,R4,R4
//Load the previous value of the pressed key from M[20] to R1//
ADDI R4,R4,020
LW   R1,R4
//R4=0, Load the next pressed key in R2//
SUB  R4,R4,R4
ADDI R4,R4,000
LW   R2,R4
OR   R1,R1,R2
//R4=0, Sending the stored value from R1 to the memory location M[20]//
SUB  R4,R4,R4
ADDI R4,R4,020
SW   R1,R4
//Jump to the check of the '*' and '#'//
J    xCheckInput
//R4=0, if the user pressed '#', sending the stored value to the memory location M[20]//
xHashtag_Pressed:
SUB  R4,R4,R4
ADDI R4,R4,020
SW   R1,R4
J    xSet_initial_value
//-------------------------------------------------------------------------------------------------//
//******************************************************************************
 *Engineer:        Youssef Taha
 * Create date:   20:24:22 05/04/2020
 * Function Name: Set_Initial_Value
 * Description:   A function that's responsible for setting initial value
                  for the counter of the pressed key
  *******************************************************************************//
  xSet_initial_value:Nop
  SUB	R1,R1,R1
  SUB	R2,R2,R2
  SUB	R3,R3,R3
  SUB	R4,R4,R4
  //CLEARING R1,R2,R3,R4=0//
  ADDI	R4,R4,021
  //STORING THE VALUE OF MEMORY ADDRESS IN R4//
  ADDI	R2,R2,020
  //STORING THE VALUE OF MEMORY ADDRESS IN R2//
  LW	R1,R2
  //LOAD THE VALUE OF M[20] IN R1??
  ANDI	R1,R1,015
  //PUTTING R1="0000 0000 0000 ****"//
  SUB	R2,R2,R2
  //CLEARING R2=0//
  ADDI	R2,R2,02
  //PUTTING R2=2//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 2 THEN JUMP 22 LINES
  TO CONDITION OF 2//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,03
  //PUTTING R2=3//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 3 THEN JUMP 22 LINES
  TO CONDITION OF 3//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,04
  //PUTTING R2=4//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 3 THEN JUMP 22 LINES
  TO CONDITION OF 4//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,05
  //PUTTING R2=5//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 5 THEN JUMP 22 LINES
  TO CONDITION OF 5//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,06
  //PUTTING R2=6//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 6 THEN JUMP 22 LINES
  TO CONDITION OF 6//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,07
  //PUTTING R2=7//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 7 THEN JUMP 22 LINES
  TO CONDITION OF 7//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,08
  //PUTTING R2=8//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 8 THEN JUMP 22 LINES
  TO CONDITION OF 8//
  SUB	R2,R2,R2
  //CLEARING R2//
  ADDI	R2,R2,09
  //PUTTING R2=9//
  BEQ	R1,R2,022
  //IF THE VALUE STORED IN R1 = 9 THEN JUMP 22 LINES
  TO CONDITION OF 9//
  //*****LEST OF NUMBERS CONDITIONS*****//
  ADDI	R3,R3,01
  //PUTTING R3=1 AS THIS IS THE INITIAL VALUE FOR THE 2 BUTTON//
  SW		R3,R4
  //STORING THE VALUE OF R4 IN THE MEMORY ADDRESS LOCATED IN R3//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_pressed_keys FUNCTION//
  ADDI	R3,R3,04
  //PUTTING R3=4 AS THIS IS THE INITIAL VALUE OF '3' BUTTON//
  SW	R3,R4	
  //STORING THE VALUW OF R4 IN THE MEMORY ADDRESS LOCATED IN R3//
  J		xcounter_of_pressed_kesys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
  ADDI	R3,R3,07
  //PUTTING R3=7 AS THIS IS THE INITIAL VALUW OF '4' BUTTON//
  SW	R3,R3	
  //STORING THE VALUE OF R4 IN THE MEMORY ADDRESS LOCATED IN R3//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
  ADDI	R3,R3,010
  //PUTTING R3=10 AS THIS IS THE INITIAL VALUE OF '5' BUTTON//
  SW	R3,R4
  //STORE THE VALUE OF R4 IN THE MEMORY ADDRESS LOCATED IN R3//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
  ADDI	R3,R3,013
  //PUTTING R3=13 AS THIS IS THE INITIAL VALUE OF '6' BUTTON//
  SW	R3,R4
  //STORING THE VALUE OF R3 IN MEMORY ADDRESS LOCATED IN R4//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
  ADDI R3,R3,016
  //PUTTING R3=16 AS THIS IS THE INITIAL VALUE OF '7' BUTTON//
  SW	R3,R4 
  //STORING THE VALUE OF R4 IN MEMORY ADDRESS LOCATED IN R3//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
  ADDI	R3,R3,020
  //PUTTING R3=20 AS THIS IS THE INITIAL VALUE OF '8' BUTTON//
  SW	R3,R4
  //STORING THE VALUE OF R4 IN MEMORY ADDRESS LOCATED IN R3//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
  ADDI	R3,R3,023
  //PUTTING R3=23 AS THIS IS THE INITIAL VALUE OF '9' BUTTON//
  SW	R3,R4
  //STORING THE VALUE OF R3 IN MEMORY ADDRESS LOCATED IN R4//
  J		xCounter_Of_Pressed_Keys
  //JUMP TO Counter_Of_Pressed_Keys FUNCTION//
  
  //******************************************************************************//
 *Engineer:       Youssef Taha 
 * Create date:   23:08:22 04/07/2020
 * MACROS Name:   ADJUST_CURSOR & PRINT_DOT & LOAD_R1
 * Description:   ADJUST_CURSOR : MOVING THE CURSOR TO THE R1,R2 coordinates
                  PRINT_DOT     : PRINTING DOTS
				  LOAD_R1       : LOADING R1 WITH THE DATA IN M[21]
			
                  
// *******************************************************************************//
 
 //MACRO THAT IS RESPONSIBLE FOR MOVING THE CURSOR TO ANY PLACE
 IN LCD JUST PUT THE ROW IN R1,COLUMN IN R2 //
 
 xADJUST_CURSOR:NOP
 SUB	R3,R3,R3
 SUB	R4,R4,R4
 ADDI	R3,R3,011
 ADDI	R4,R4,012
 SW		R1,R3
 SW		R2,R4
 J 	    xLCD_goToRowColumn
 
 //**************************************************************************//
 
 //MACRO THAT IS RESPONSIBLE FOR GETTING THE ASCII CODE OF DOT IN M[21]
 AND PRINT IT //
 
 xPRINT_DOT:NOP
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R2,022
 LW		R1,R2
 SUB	R2,R2,R2
 ADDI	R2,R2,010
 SW		R1,R2
 J	    xLCD_displayCharacter 
 
 //***************************************************************************//
 
 //MACRO THAT IS RESPONSIBLE FOR LOADING R1 WITH DATA IN M[21]//
 
 xLOAD_R1:NOP
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R2,R2,021
 LW		R1,R2
 JR		R7
 
 //****************************************************************************//
 
//-------------------------------------------------------------------------------------------------------//

//******************************************************************************
 * Engineer:      Yahya Hamdy
 * Create date:   1:16:17 06/04/2020
 * Function Name: xCounter_Of_Pressed_Keys
 * Description:  Converting the input to a value poinnting at the 
                 number of the wanted alphapetic letter as the used assembler 
		 is not supporting an immediate value more than 031
 * Inputs:        Data to be printed and initial value of the counter
 * Outputs:       New value of the counter that points at the number 
                  of the wanted alphapetic letter
 *******************************************************************************//
xCounter_Of_Pressed_Keys:NOP
//Clear Registers R1,R2,R3,R4//
SUB R1,R1,R1
SUB R2,R2,R2
SUB R3,R3,R3
SUB R4,R4,R4

//Setting R3,R4 with the values of the input and counter initial value memory locations//
ADDI R3,R3,020
ADDI R4,R4,021

//Storing the entered value in R1 and the initial value of the counter in R2//
LW R1,R3
LW R2,R4 

//Shift Right R1 by 4 bits and storing the shifted value in R3//
SUB R3,R3,R3
SRL R3,R1
SRL R3,R3
SRL R3,R3
SRL R3,R3

//Jump to the display procedure after reading the input successfully and keeping the value of the counter unchanged//
ANDI R3,R3,015
SUB R4,R4,R4
BNE R3,R4,02
J xSend_"YOU ENTERD"_Message

//The key is pressed again so the value of the counter will be incremented//
ADDI R2,R2,01

//Store the new value of the counter in memory//
SUB R3,R3,R3
ADDI R4,R4,021
SW R2,R4

//Read the next nibble and check if the key is pressed again//
SRL R3,R1
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
ANDI R3,R3,015
SUB R4,R4,R4
BEQ R3,R4,02
J xSend_"YOU ENTERD"_Message

ADDI R2,R2,01
SUB R3,R3,R3
ADDI R4,R4,021
SW R2,R4

//Read the next nibble and check if the key is pressed again//
SRL R3,R1
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
SRL R3,R3
ANDI R3,R3,015
SUB R4,R4,R4
BEQ R3,R4,02
J xSend_"YOU ENTERD"_Message
ADDI R2,R2,01
SUB R3,R3,R3
ADDI R4,R4,021
SW R2,R4

//The input is read successfully , Jump to the display procedure//
J xSend_"YOU ENTERD"_Message
//-------------------------------------------------------------------------------------------------------------------------------------//
//***********************************************
*Engineer        : Mohamed Ammar
*Creat date      : 6/4/2020 
*Edited          : 7/4/2020
*Function name   : Send_"YOU ENTERD"_Message
*Description     : A function to print string 

***********************************************//

 xSend_"YOU ENTERD"_Message

 // PRINTING Y //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,29
 ADDI R2,R2,10
 SW   R1,R2

 // GOTO ROW 1 // 
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADDI R1,R1,1
 ADDI R2,R2,11
 SW   R1,R2
 
 //GOTO COL1 //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADDI R1,R1,1
 ADDI R2,R2,12
 SW   R1,R2
 
 JAL xLCD_goToRowColumn
 JAL xLCD_displayCharacter 
 
 // PRINTING O //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,19
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 

 // PRINTING U //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,25
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 
 
 // PRINTING SPACE //
 SUB  R1,R1,R1  
 SUB  R2,R2,R2
 ADDI R1,R1,30
 ADDI R1,R1,2
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 
 
 // PRINTING E //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,9
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter

 // PRINTING N //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,18
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter

 // PRINTING T //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,24
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter

 // PRINTING E //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,9
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 

 // PRINTING R //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,22
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter

 // PRINTING E //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,9
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 

 // PRINTING D //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADD  R1,R1,30
 ADDI R1,R1,30
 ADDI R1,R1,8
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter

 // PRINTING : //
 SUB  R1,R1,R1  
 SUB  R2,R2,R2
 ADDI R1,R1,30
 ADDI R1,R1,28
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 
 
 // PRINTING SPACE //
 SUB  R1,R1,R1  
 SUB  R2,R2,R2
 ADDI R1,R1,30
 ADDI R1,R1,2
 ADDI R2,R2,10
 SW   R1,R2
 JAL xLCD_displayCharacter 
 

 // ASCII CODE OF REQUIRED LETTER //
 SUB  R1,R1,R1
 SUB  R2,R2,R2
 ADDI R2,R2,21
 LW   R1,R2
 ADDI R1,R1,30 
 ADDI R1,R1,30
 ADDI R1,R1,4

 //  PRINTING THE LETTER  //
 SUB  R2,R2,R2
 ADDI R2,R2,10
 SW   R1,R2 
 JAL xLCD_displayCharacter 
//-------------------------------------------------------------------------------------------------------------------------------------// 
 //******************************************************************************
 * Engineer:      Mohamed AMMAR & YAHYA HAMDY & YOUSSEF TAHA
 * Create date:   23:08:22 04/07/2020
 * Function Name: PRINT_BRAILLE_CHARACTER
 * Description:   A function that's responsible for converting the character 
                  to braille language
 *     
 * Inputs:        The Character Number
 * Outputs:       void
 *******************************************************************************//
 
 //PUTTING DOT ASCII IN M[22]//
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,030
 ADDI	R1,R1,016
 ADDI	R2,R2,022
 SW		R1,R2

 //****************************************************************************//
 //THE VALUE OF THE CHARACTER STORED IN M[21] SO WE LOAD R1 WITH M[21]
   ,COMPARE THE CHARACTER NUMBER WITH ALL CHARACTERS NUMBERS IF THERE IS A MATCH 
   WE PRINT THE CHARACTER IN BRAILLE LANGUAGE //
 //****************************************************************************//
 
 xCHECK_A:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,01
 
 //IF THE CHARACTER IS 'A' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
   TO THE 'A' DRAWING LINES OF CODE IF IT ISN'T 'A' WE JUMP TO NEXT LINE OF BEQ 
   WHICH IS CHECK_B//
   
 BEQ	R1,R2,02
 J		xCHECK_B
 
 // 'A' DRAWING LINE OF CODE THAT PRINT A IN BRAILLE
     ". "//
 
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_B:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,02
 
  //IF THE CHARACTER IS 'B' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
   TO THE 'B' DRAWING LINES OF CODE IF IT ISN'T 'B' WE JUMP TO NEXT LINE OF BEQ 
   WHICH IS CHECK_C//
   
 BEQ 	R1,R2,02
 J		xCHECK_C
 
  // 'B' DRAWING LINES OF CODE THAT PRINT 'B' IN BRAILLE
     ". "
     ". "//
 
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_C:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,03
 
   //IF THE CHARACTER IS 'C' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
   TO THE 'C' DRAWING LINES OF CODE IF IT ISN'T 'C' WE JUMP TO NEXT LINE OF BEQ 
   WHICH IS CHECK_D//
   
 BEQ	R1,R2,02
 J		xCHECK_D
 
   // 'C' DRAWING LINES OF CODE THAT PRINT 'C' IN BRAILLE
      ". ."
      "   "//
 
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_D:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,04
 
    //IF THE CHARACTER IS 'D' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
   TO THE 'D' DRAWING LINES OF CODE IF IT ISN'T 'D' WE JUMP TO NEXT LINE OF BEQ 
   WHICH IS CHECK_E//
   
 BEQ	R1,R2,x02
 J		xCHECK_E
 
    // 'D' DRAWING LINES OF CODE THAT PRINT 'D' IN BRAILLE
        ". ."
        "  ."//
 
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_E:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R1,R1,05
 
    //IF THE CHARACTER IS 'E' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
   TO THE 'E' DRAWING LINES OF CODE IF IT ISN'T 'E' WE JUMP TO NEXT LINE OF BEQ 
   WHICH IS CHECK_F//
   
 BEQ	R1,R2,02
 J		xCHECK_F
 
     // 'D' DRAWING LINES OF CODE THAT PRINT 'D' IN BRAILLE
        ".  "
        "  ."//
 
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_F:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,06
 
   //IF THE CHARACTER IS 'F' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
   TO THE 'F' DRAWING LINES OF CODE IF IT ISN'T 'F' WE JUMP TO NEXT LINE OF BEQ 
   WHICH IS CHECK_G//
   
 BEQ	R1,R2,02
 J		xCHECK_G
 
      // 'F' DRAWING LINES OF CODE THAT PRINT 'F' IN BRAILLE
          ". ."
          "  ."//
 
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_G:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,07
 
    //IF THE CHARACTER IS 'G' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'G' DRAWING LINES OF CODE IF IT ISN'T 'G' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_H//
   
 BEQ	R1,R2,02
 J		xCHECK_H
 
       // 'G' DRAWING LINES OF CODE THAT PRINT 'G' IN BRAILLE
          ". ."
          ". ."//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT

xCHECK_H:NOP
 JAL	xLOAD_R1
 SUB	R2,R,R2
 ADDI	R2,R2,08
 
     //IF THE CHARACTER IS 'H' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'H' DRAWING LINES OF CODE IF IT ISN'T 'H' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_I//
	  
 BEQ	R1,R2,02
 J		xCHECK_I
 
       // 'H' DRAWING LINES OF CODE THAT PRINT 'H' IN BRAILLE
          ".  "
          ". ."//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT

 xCHECK_I:NOP
  JAL	xLOAD_R1
 SUB	R2,R,R2
 ADDI	R2,R2,09
      //IF THE CHARACTER IS 'I' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'I' DRAWING LINES OF CODE IF IT ISN'T 'I' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_J//
	  
 BEQ	R1,R2,02
 J		xCHECK_J
 
        // 'I' DRAWING LINES OF CODE THAT PRINT 'I' IN BRAILLE
          "  ."
          ".  "//
 
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_J:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,010
 
    //IF THE CHARACTER IS 'J' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'J' DRAWING LINES OF CODE IF IT ISN'T 'J' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_K//
   
 BEQ	R1,R2,02
 J		xCHECK_K
 
       // 'J' DRAWING LINES OF CODE THAT PRINT 'J' IN BRAILLE
          "  ."
          ". ."//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_K:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,011
 
    //IF THE CHARACTER IS 'K' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'K' DRAWING LINES OF CODE IF IT ISN'T 'K' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_L//
   
 BEQ	R1,R2,02
 J		xCHECK_L
 
       // 'K' DRAWING LINES OF CODE THAT PRINT 'K' IN BRAILLE
          ".  "
          "   "
          ".  "//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_L:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,012
 
    //IF THE CHARACTER IS 'L' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'L' DRAWING LINES OF CODE IF IT ISN'T 'L' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_M//
   
 BEQ	R1,R2,02
 J		xCHECK_M
 
       // 'L' DRAWING LINES OF CODE THAT PRINT 'L' IN BRAILLE
          ".  "
          ".  "
          ".  "//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_M:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,013
 
    //IF THE CHARACTER IS 'M' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'M' DRAWING LINES OF CODE IF IT ISN'T 'M' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_N//
   
 BEQ	R1,R2,02
 J		xCHECK_N
 
       // 'M' DRAWING LINES OF CODE THAT PRINT 'M' IN BRAILLE
          ". ."
          "   "
          ".  "//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_N:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,014
 
    //IF THE CHARACTER IS 'N' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'N' DRAWING LINES OF CODE IF IT ISN'T 'N' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_O//
   
 BEQ	R1,R2,02
 J		xCHECK_O
 
       // 'N' DRAWING LINES OF CODE THAT PRINT 'N' IN BRAILLE
          ". ."
          "  ."
          ".  "//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_O:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,015
 
    //IF THE CHARACTER IS 'O' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'O' DRAWING LINES OF CODE IF IT ISN'T 'O' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_P//
   
 BEQ	R1,R2,02
 J		xCHECK_P
 
       // 'O' DRAWING LINES OF CODE THAT PRINT 'O' IN BRAILLE
          ".  "
          "  ."
          ".  "//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_P:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,016
 
    //IF THE CHARACTER IS 'P' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'P' DRAWING LINES OF CODE IF IT ISN'T 'P' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_Q//
   
 BEQ	R1,R2,02
 J		xCHECK_Q
 
       // 'P' DRAWING LINES OF CODE THAT PRINT 'P' IN BRAILLE
          ". ."
          ".  "
          ".  "//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
  xCHECK_Q:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,017
 
    //IF THE CHARACTER IS 'Q' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'Q' DRAWING LINES OF CODE IF IT ISN'T 'Q' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_R//
   
 BEQ	R1,R2,02
 J		xCHECK_R
 
       // 'Q' DRAWING LINES OF CODE THAT PRINT 'Q' IN BRAILLE
          ". ."
          ". ."
          ".  "//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 
 xCHECK_R:NOP
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,018
 
    //IF THE CHARACTER IS 'R' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'R' DRAWING LINES OF CODE IF IT ISN'T 'R' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_S//
   
 BEQ	R1,R2,02
 J		xCHECK_S
 
       // 'R' DRAWING LINES OF CODE THAT PRINT 'R' IN BRAILLE
          ".  "
          ". ."
          ".  "//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 JAL	xADJUST_CURSOR
 JAL	xPRINT_DOT
  
 xCHECK_S:NOP
 SUB    R7,R7,R7
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,019
 
    //IF THE CHARACTER IS 'S' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'S' DRAWING LINES OF CODE IF IT ISN'T 'S' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_T//
   
 BEQ	R1,R2,02
 J		xCHECK_T
 
       // 'S' DRAWING LINES OF CODE THAT PRINT 'S' IN BRAILLE
          "  ."
          ".  "
          ".  "//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 
 xCHECK_T:NOP
 SUB    R7,R7,R7
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,020
 
    //IF THE CHARACTER IS 'T' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'T' DRAWING LINES OF CODE IF IT ISN'T 'T' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_U//
   
 BEQ	R1,R2,02
 J		xCHECK_U
 
       // 'T' DRAWING LINES OF CODE THAT PRINT 'T' IN BRAILLE
          "  ."
          ". ."
          ".  "//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 
 xCHECK_U:NOP
 SUB    R7,R7,R7
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,021
 
    //IF THE CHARACTER IS 'U' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'U' DRAWING LINES OF CODE IF IT ISN'T 'U' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_V//
   
 BEQ	R1,R2,02
 J		xCHECK_V
 
       // 'U' DRAWING LINES OF CODE THAT PRINT 'U' IN BRAILLE
          ".  "
          "   "
          ". ."//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,02
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 
  xCHECK_V:NOP
 SUB    R7,R7,R7
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,022
 
    //IF THE CHARACTER IS 'V' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'V' DRAWING LINES OF CODE IF IT ISN'T 'V' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_W//
   
 BEQ	R1,R2,02
 J		xCHECK_W
 
       // 'V' DRAWING LINES OF CODE THAT PRINT 'V' IN BRAILLE
          ".  "
          ".  "
          ". ."//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,02
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 
 xCHECK_W:NOP
 SUB    R7,R7,R7
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,023
 
    //IF THE CHARACTER IS 'W' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'W' DRAWING LINES OF CODE IF IT ISN'T 'W' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_X//
   
 BEQ	R1,R2,02
 J		xCHECK_X
 
       // 'W' DRAWING LINES OF CODE THAT PRINT 'W' IN BRAILLE
          "  ."
          ". ."
          "  ."//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,01
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,02
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 
 xCHECK_X:NOP
 SUB    R7,R7,R7
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,024
 
    //IF THE CHARACTER IS 'X' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'X' DRAWING LINES OF CODE IF IT ISN'T 'X' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_Y//
   
 BEQ	R1,R2,02
 J		xCHECK_Y
 
       // 'X' DRAWING LINES OF CODE THAT PRINT 'X' IN BRAILLE
          ". ."
          "   "
          ". ."//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,02
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 
  xCHECK_Y:NOP
 SUB    R7,R7,R7
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,025
 
    //IF THE CHARACTER IS 'Y' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'Y' DRAWING LINES OF CODE IF IT ISN'T 'W' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS CHECK_Z//
   
 BEQ	R1,R2,02
 J		xCHECK_Z
 
       // 'Y' DRAWING LINES OF CODE THAT PRINT 'Y' IN BRAILLE
          ". ."
          "  ."
          ". ."//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,02
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,02
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 
   xCHECK_Z:NOP
 SUB    R7,R7,R7
 JAL	xLOAD_R1
 SUB	R2,R2,R2
 ADDI	R2,R2,026
 
    //IF THE CHARACTER IS 'Z' WE DRAW THE LETTER IN BRAILLE AS WE JUMP 2 LINES
      TO THE 'Z' DRAWING LINES OF CODE IF IT ISN'T 'Z' WE JUMP TO NEXT LINE OF BEQ 
      WHICH IS ERROR//
   
 BEQ	R1,R2,02
 J		xERROR
 
       // 'Z' DRAWING LINES OF CODE THAT PRINT 'Z' IN BRAILLE
          ".  "
          "  ."
          ". ."//
		  
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,02
 ADDI	R2,R2,01
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,03
 ADDI	R2,R2,02
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,01
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 SUB	R1,R1,R1
 SUB	R2,R2,R2
 ADDI	R1,R1,04
 ADDI	R2,R2,02
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 SUB    R7,R7,R7
 JAL	xPRINT_DOT
 
 // DELAY TO KEEP THE LETTER ON THE SCREEN FOR 3SEC //
 
 SUB    R3,R3,R3
 ADDI   R2,R2,01
 ADDI   R0,R0,01
 SLL R0
 SLL R0
 SLL R0
 SLL R0
 SLL R0
 SLL R0
 SLL R0
 SLL R0
 SLL R0
 SLL R0
 ADDI   R0,R0,R0
 ADDI   R0,R0,R0
 ADDI   R0,R0,R0
 xLOOP:NOP
 JAL    xDelay
 SUB    R0,R0,R2
 
 BEQ R0,R3,03
 J xLOOP
 SUB    R7,R7,R7
 JAL    xLCD_clearScreen
 J	xMAIN
 

 // IF THE CHARACTER ISN'T ANY ONE OF THE ALPHABETIC OR ANY ERROR
    OCCURED DURING CHECKING THE LETTER THE LCD SHOULD PRINT ERROR //
	
 xERROR : NOP
 SUB    R7,R7,R7
 JAL    xLCD_clearScreen
 SUB    R1,R1,R1
 SUB    R2,R2,R2
 ADDI   R1,R1,02
 ADDI   R2,R2,01
 SUB    R7,R7,R7
 JAL	xADJUST_CURSOR
 
 // PRINTING E //
 SUB   R1,R1,R1
 SUB   R2,R2,R2
 ADD   R1,R1,30
 ADDI  R1,R1,30
 ADDI  R1,R1,9
 ADDI  R2,R2,10
 SW    R1,R2
 SUB   R7,R7,R7
 JAL xLCD_displayCharacter
  
 // PRINTING R //
 SUB   R1,R1,R1
 SUB   R2,R2,R2
 ADD   R1,R1,30
 ADDI  R1,R1,30
 ADDI  R1,R1,22
 ADDI  R2,R2,10
 SW    R1,R2
 SUB   R7,R7,R7
 JAL xLCD_displayCharacter
 
 // PRINTING R //
 SUB   R1,R1,R1
 SUB   R2,R2,R2
 ADD   R1,R1,30
 ADDI  R1,R1,30
 ADDI  R1,R1,22
 ADDI  R2,R2,10
 SW    R1,R2
 SUB   R7,R7,R7
 JAL xLCD_displayCharacter
 
 // PRINTING O //
 SUB   R1,R1,R1
 SUB   R2,R2,R2
 ADD   R1,R1,30
 ADDI  R1,R1,30
 ADDI  R1,R1,19
 ADDI  R2,R2,10
 SW    R1,R2
 SUB   R7,R7,R7
 JAL xLCD_displayCharacter
 
 // PRINTING R //
 SUB   R1,R1,R1
 SUB   R2,R2,R2
 ADD   R1,R1,30
 ADDI  R1,R1,30
 ADDI  R1,R1,22
 ADDI  R2,R2,10
 SW    R1,R2
 SUB   R7,R7,R7
 JAL xLCD_displayCharacter
 
  // DELAY TO KEEP THE WORD "ERROR" ON THE SCREEN FOR 3SEC //
 
 SUB    R3,R3,R3
 ADDI   R2,R2,01
 ADDI   R0,R0,01
 SLL R0
 SLL R0
 SLL R0
 SLL R0
 SLL R0
 SLL R0
 SLL R0
 SLL R0
 SLL R0
 SLL R0
 ADDI   R0,R0,R0
 ADDI   R0,R0,R0
 ADDI   R0,R0,R0
 xLOOP:NOP
 JAL    xDelay
 SUB    R0,R0,R2
 
 BEQ R0,R3,03
 J xLOOP
 SUB    R7,R7,R7
 JAL    xLCD_clearScreen
 J	xMAIN 

 //****************************************************************************//
 
//-------------------------------------------------------------------------------------------------------//

//******************************************************************************
*Engineer        : Reem Saleh
*Create date      : 10:10:26 8/4/2020 
*Function name   : xLCD_init
*Description     : Initialize the LCD internal registers and configure LCD Data/Control pins
xLCD_init:
// putting R0=R1=R2=0 //
 SUB  R0,R0,R0 
 SUB  R1,R1,R1
 SUB  R2,R2,R2
// Sending Command 38H, 8 bit mode //
 // RS=RW=0 --->  R0 AND 0b1110011111111111 //
  // Creating the bitmask 0b1110011111111111 //
   ADDI R1,R1,7
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   OR   R2,R2,R1
   SUB  R1,R1,R1
   ADDI R1,R1,7
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   OR   R2,R2,R1
   SUB  R1,R1,R1
   ADDI R1,R1,15
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   ADDI R1,R1,15
   OR   R2,R2,R1
   AND  R0,R0,R2
   OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // E=1 --->  R0 OR 0b0000010000000000 //
  SUB  R1,R1,R1
  ADDI R1,R1,1
  SLL R1,R1
  SLL R1,R1
  SLL R1,R1
  SLL R1,R1
  SLL R1,R1
  SLL R1,R1
  SLL R1,R1
  SLL R1,R1
  SLL R1,R1
  SLL R1,R1
  OR  R0,R1
  OUT R0
  // Delay for 1ms //
   SUB  R1,R1,R1
   ADDI R1,R1,18
   SW   R7,R1
   JAL  XDelay 
   SUB  R1,R1,R1
   ADDI R1,R1,18
   LW   R7,R1
 // Command = 38H ---> R0 OR 0b0000000011100000 //
  // Creating the bitmask 0b0000000011100000 //  
   SUB  R1,R1,R1
   ADDI R1,R1,7
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   OR   R0,R1
   OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // E=0 --->  R0 AND 0b1111101111111111 //
  SUB  R1,R1,R1
  SUB  R2,R2,R2
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,01
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  ADDI R1,03
  OR   R2,R1
  AND  R0,R2
  OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
// Sending Command 0FH, Display on cursor blinking // 
 // RS=RW=0 --->  R0 AND 0b1110011111111111 //
  // Creating the bitmask 0b1110011111111111 //
   SUB  R1,R1,R1 
   ADDI R1,R1,7
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   OR   R2,R2,R1
   SUB  R1,R1,R1
   ADDI R1,R1,7
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   OR   R2,R2,R1
   SUB  R1,R1,R1
   ADDI R1,R1,15
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   ADDI R1,R1,15
   OR   R2,R2,R1
   AND  R0,R0,R2
   OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // E=1 --->  R0 OR 0b0000010000000000 //
  SUB  R1,R1,R1
  ADDI R1,R1,1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R0,R1
  OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // Command = 0FH ---> R0 OR 0b0000000000111100 //
  SUB  R1,R1,R1
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  OR   R0,R1
  OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // E=0 --->  R0 AND 0b1111101111111111 //
  SUB  R1,R1,R1
  SUB  R2,R2,R2
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,01
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  ADDI R1,03
  OR   R2,R1
  AND  R0,R2
  OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
// Sending Command 01H, Clear Screen // 
 // RS=RW=0 --->  R0 AND 0b1110011111111111 //
  // Creating the bitmask 0b1110011111111111 //
   SUB  R1,R1,R1 
   ADDI R1,R1,7
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   OR   R2,R2,R1
   SUB  R1,R1,R1
   ADDI R1,R1,7
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   OR   R2,R2,R1
   SUB  R1,R1,R1
   ADDI R1,R1,15
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   ADDI R1,R1,15
   OR   R2,R2,R1
   AND  R0,R0,R2
   OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // E=1 --->  R0 OR 0b0000010000000000 //
  SUB  R1,R1,R1
  ADDI R1,R1,1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R0,R1
  OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // Command = 01H ---> R0 OR 0b0000000000000100 //
  SUB  R1,R1,R1
  ADDI R1,R1,01
  SLL  R1,R1
  SLL  R1,R1
  OR   R0,R1
  OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // E=0 --->  R0 AND 0b1111101111111111 //
  SUB  R1,R1,R1
  SUB  R2,R2,R2
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,01
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  ADDI R1,03
  OR   R2,R1
  AND  R0,R2
  OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
// Sending Command 06H, Entery mode, auto increment with no shift // 
 // RS=RW=0 --->  R0 AND 0b1110011111111111 //
  // Creating the bitmask 0b1110011111111111 //
   SUB  R1,R1,R1 
   ADDI R1,R1,7
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   OR   R2,R2,R1
   SUB  R1,R1,R1
   ADDI R1,R1,7
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   OR   R2,R2,R1
   SUB  R1,R1,R1
   ADDI R1,R1,15
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   SLL  R1,R1
   ADDI R1,R1,15
   OR   R2,R2,R1
   AND  R0,R0,R2
   OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // E=1 --->  R0 OR 0b0000010000000000 //
  SUB  R1,R1,R1
  ADDI R1,R1,1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R0,R1
  OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // Command = 06H ---> R0 OR 0b0000000000011000 //
  SUB  R1,R1,R1
  ADDI R1,R1,3
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R0,R1
  OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
 // E=0 --->  R0 AND 0b1111101111111111 //
  SUB  R1,R1,R1
  SUB  R2,R2,R2
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,01
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  SLL  R1,R1
  OR   R2,R1
  SUB  R1,R1
  ADDI R1,R1,15
  SLL  R1,R1
  SLL  R1,R1
  ADDI R1,03
  OR   R2,R1
  AND  R0,R2
  OUT  R0
 // Delay for 1ms //
  SUB  R1,R1,R1
  ADDI R1,R1,18
  SW   R7,R1
  JAL  XDelay 
  SUB  R1,R1,R1
  ADDI R1,R1,18
  LW   R7,R1
// Clearing The Registers used in the function (R0,R1,R2,R3) //
 SUB  R0,R0,R0
 SUB  R1,R1,R1
 SUB  R2,R2,R2
JR   R7 
//****************************************************************************** //
* Engineer: May Sherif-Aya Ahmed-Aya Mohamed
 * Create date: 21:04:22 15/04/2020
 * Function Name:Keypad_GetPressedKey
 * Description: A function that's responsible for detecting the key pressed in the keypad 
* Inputs: void
* Outputs:value of pressed key
// *****************************************************************************//
Keypad_GetPressedKey
       SUB R1,R1,R1
//to make R1equal zero.
       SUB R0,R0,R0 
//to make R0equal zero.
       OUT R0
//out zeros to all rows(ensure that all   keys are open).
K1:     IN R0 
//read columns make R0equal zero..
       ANDI R0,R0,0007H
//mask the last 3 bits.
       ADDI R1,R1,0007H 
//move 07h to R1.      
       BNQ R0,R1,0001H
// making sure that all keys are    released.
       J K1//go to check again on columns.
     JAL DELAY_0
     JAL DELAY_0
     JAL DELAY_0
     JAL DELAY_0
     JAL DELAY_0
     JAL DELAY_0
     JAL DELAY_0
     JAL DELAY_0
// calling the delay_0 function 8 times to delay 20 ms as each delays 2.6 ms
K2: SUB R0,R0,R0
//to make R0equal zero.
       IN R0
//read columns.
        ANDI R0,R0,0007H 
//mask the last 3 bits.
        ANDI R1,R1,0000H
 //to make R0equal zero.
        ADDI R1,R1,0007H 
//move 07h to R1.      
       BNQ R0,R1,0001H
//see if any key is pressed?
        J K2
//keep checking again till akey is pressed.
     JAL DELAY_0
     JAL DELAY_0
     JAL DELAY_0
     JAL DELAY_0
     JAL DELAY_0
     JAL DELAY_0
     JAL DELAY_0
     JAL DELAY_0
// calling the delay_0 function 8 times to delay 20 ms as each delays 2.6 ms
SUB R0,R0,R0
 //to make R0equal zero.
IN R0
//read columns
ANDI R0,R0,0007H
 //mask the last 3 bits.
ANDI R1,R1,0000H
 //to make R1equal zero.
ADDI R1,R1,0007H 
//move 07h to R1.      
BNQ R0,R1,0001H
//check if key was still pressed after debounce time (20ms).
J K2
//return check if a key is pressed.
ANDI R0,R0,0000H
 //to make R0 equal zero.
ADDI R0,R0,FFFEH
//ground row 0.
OUT R0
//out R0 on the rows.
SUB R0,R0,R0 
//to make R0equal zero.
IN R0
//read columns.
ANDI R0,R0,0007H
//masking the last 3 bits .
ANDI R1,R1,0000H
//tomake R1 equals zero.
ADDI R1,R1,0007H
 //move 07h to R1.      
BEQ R0,R1,0003H
//compare to find if any column gives a zero or not ?
ANDI R1,R1,000H 
//to make R1 equals zero.
ADDI R1,R1,FFFEH
//if so store value of row 1 in R1.
J FIND-IT
//call find it to get the value of the pressed key .
RO-1:    ANDI R0,R0,0000H 
//to make R1 equals zero.
ADDI R0,R0,FFFDH
//ground row 1.
OUT R0
//out R0 value on all rows.
SUB R0,R0,R0
//to make R0equal zero.
IN R0
//read columns.
ANDI R0,R0,0007H
//masking the last 3 bits .
ANDI R1,R1,0000H 
//tomake R0 equals zero.
ADDI R1,R1,0007H
 //move 07h to R1.      
BEQ R0,R1,0003H
//compare to find if any column gives a zero or not ?
ANDI R1,R1,0000H 
//tomake R1 equals zero.
ADDI R1,R1,FFFDH
 //if so store value of row 1in R1.
J FIND-IT 
//call find it to get the value of the pressed key .
RO-2: ANDI R0,R0,0000H
 //tomake R0 equals zero.
ADDI R0,R0,FFFCH
//ground row2.
OUT R0
 //out R0 value on all rows.
SUB R0,R0,R0 
//to make R0equal zero.
IN R0
 //read columns.
ANDI R0,R0,0007H
//masking the last 3 bits .
ANDI R1,R1,0000H
 //to make R1equal zero.
ADDI R1,R1,0007H 
//move 07h to R1.      
BEQ R1,R0,0003H
//compare to find if any column gives a zero or not ?

ANDI R1,R1,0000H
 //to make R1equal zero.
ADDI R1,R1,FFFCH
 //if so store value of row 2 in R1.
J FIND-IT
//call find it to get the value of the pressed key .
RO-3: ANDI R0,R0,0000H
 //to make R0equal zero.
ADDI R0,R0,FFFBH
//ground row3.
OUT R0
//out R0 value on all rows.
SUB R0,R0,R0
//to make R0equal zero.
IN R0
 //read columns.
ANDI R0,R0,0007H 
//masking the last 3 bits .
ANDI R1,R1,0000H
 //to make R1equal zero.
ADDI R1,R1,0007H //move value of 07 to R1.
BNQ R1,R0, 0001H 
//compare to find if any column gives a zero or not ?
J K2
//retry checking the keys again.
ANDI R1,R1,0000H 
//to make R1equal zero.
ADDI R1,R1,FFFBH 
//if so store value of row 3in R1.
J FIND-IT
//call find it to get the value of the pressed key .

// a function to find the value of the pressed key 

FIND-IT:
  // row 0 keys
ANDI R3,R3,0000H 
//to make R3 equal zero.
ADDI R3,R3,FFFEH
//put value of row 0 in R3.
BNQ R1,R3,000CH
//detect wether we are in row 0 or not??
ANDI R4,R4,0000H
 //to make R4 equal zero.
ADDI R4,R4,0006H 
BNQ R4,R0,0003H
 //detect wether 1st col is  inverted or not??
ANDI R2,R2,0000H 
//to make R2 equal zero.
ADDI R2,R2,0003H
//key ‘3’is pressed
J STORE
// go to store value of key ‘3’.
ANDI R4,R4,0000H 
//to make R4 equal zero.
ADDI R4,R4,0005H 
BNQ R4,R0,0003h 
//detect wether 2nd  col is  inverted or not??
ANDI R2,R2,0000H
 //to make R2 equal zero.
ADDI R2,R2,0002H
 //key ‘2’is pressed
J STORE
// go to store value of key ‘2’.

// row 1 keys
ANDI R3,R3,0000H
 //to make R3 equal zero.
ADDI R3,R3,FFFDH 
//put value of row 1 in R3.
BNQ R1,R3,0011H
//detect wether we are in row 0 or not??
ANDI R4,R4,0000H 
//to make R4 equal zero.
ADDI R4,R4,0006H 
BNQ R4,R0,0003H
 //detect wether 1st col is  inverted or not??
ANDI R2,R2,0000H
 //to make R2 equal zero.
ADDI R2,R2,0006H 
//key ‘6’is pressed.
J STORE
// go to store value of key ‘6’.
ANDI R4,R4,0000H 
//to make R4 equal zero.
ADDI R4,R4,0005H
BNQ R4,R0,0003H 
 //detect wether 2ND col is  inverted or not??
ANDI R2,R2,0000H 
//to make R2 equal zero.
ADDI R2,R2,0005H//KEY'5' is pressed.
J STORE
//go to store the value of key ‘5’.
ANDI R4,R4,0000H
 //to make R4 equal zero.
ADDI R4,R4,0004H 
BNQ R4,R0,0003H 
//detect wether 3rd  col is  inverted or not??
ANDI R2,R2,0000H
 //to make R2 equal zero.
ADDI R2,R2,0004H
//key’4’is pressed.
J STORE
//go to store the value of key ‘4’.

// row 2 keys
ANDI R3,R3,0000H 
//to make R3 equal zero.
ADDI R3,R3,FFFCH
BNQ R1,R3,0011H
//detect wether we are in row 2 or not??
ANDI R4,R4,0000H
 //to make R4 equal zero.
ADDI R4,R4,0006H
BNQ R4,R0,0003H 
//detect wether 1st col is  inverted or not??
ANDI R2,R2,0000H
//to make R2 equal zero.
ADDI R2,R2,0009H 
//key’9’is pressed.
J STORE
//go to store the value of key ‘9’.
ANDI R4,R4,0000H
 //to make R4 equal zero.
ADDI R4,R4,0005H 
BNQ R4,R0,0003H
 //detect wether 2nd  col is  inverted or not??
ADDI R2,R2,0000H 
//to make R2 equal zero.
ANDI R2,R2,0008H
 //key’8’is pressed.
J STORE
//go to store the value of key ‘8’.
AND R4,R4,00000H
 //to make R4 equal zero.
ADDI R4,R4,0004H
BNQ R4,R0,0003H
//detect wether 3rd  col is  inverted or not??
ANDI R2,R2,0000H 
//to make R2equal zero.
ADDI R2,R2,0007H
 //key’7’is pressed.
J STORE
//go to store the value of key ‘7’.

//row 3 keys
ANDI R4,R4,0000H
 //to make R4 equal zero.
ADDI R4,R4,0006H 
BNQ R4,R0,0003H
 //detect wether 1st col is  inverted or not??
ANDI R2,R2,0000H
ADDI R2,0001H
//key’#’is pressed.
J STORE
//go to store the value of key ‘#’.
ANDI R2,R2,0000H 
//key’*’is pressed.
J STORE
//go to store the value of key ‘*’.

// a function to store the value of pressed key

STORE: ADDI R0,R0,0000H 
//adds in Ro 0 
             SW R2,R0
             SUB R0,R0,R0
             SUB R1,R1,R1
             SUB R2,R2,R2
             SUB R3,R3,R3
             SUB R4,R4,R4
//stores value in R2 in Memory address in R0

//Delay_0 function
//Function Discription: Delays for 2.6 ms
//Name:Youssef Galal
 //assuming that the clock used is 25MHz,1 cycle takes 40ns
 //counter = 2.6ms/40ns = 65000 counts

 Delay_0 :
 SUB R5,R5,R5
 SUB R6,R6,R6
 //R6=0,R5=0
ADDI R6,R6,FDE8h
 //storing the value 65000 in R6
 xLoop_0:        ADDI R5,R5,01
 //R5 accumulates untill it reaches 65000
  NOP
 BEQ R5,R6,01 
//if R5 reaches R6 "65000" we will skip the jump line
 J xLoop_0
//if R5 doesn't reach R6 "65000" we will go to xLoop again
SUB R5,R5,R5 
SUB R6,R6,R6
 //clearing the registers used

